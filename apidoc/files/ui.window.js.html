<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>ui.window.js - Zebra API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.8.0pr2/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="http://yui.yahooapis.com/combo?3.8.0pr2/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1>Zebra API: ui.window.js</a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 07/2013</em>
        </div>
    </div>
    <div class="yui3-g">

        <div id="sidebar" class="yui3-u">
            <div id="modules" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Packages</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="../modules/data.html">data</a>
                
                </li>
            
                <li><a href="../modules/io.html">io</a>
                
                </li>
            
                <li><a href="../modules/layout.html">layout</a>
                
                </li>
            
                <li><a href="../modules/ui.html">ui</a>
                
                </li>
            
                <li><a href="../modules/ui.designer.html">ui.designer</a>
                
                </li>
            
                <li><a href="../modules/ui.grid.html">ui.grid</a>
                
                </li>
            
                <li><a href="../modules/ui.tree.html">ui.tree</a>
                
                </li>
            
                <li><a href="../modules/util.html">util</a>
                
                </li>
            
                <li><a href="../modules/zebra.html">zebra</a>
                
                </li>
            
        </ul>
    </div>
</div>

<div id="classes" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Classes and interfaces</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="../classes/zebra.Class().html">zebra.Class()</a></li>
            
                <li><a href="../classes/zebra.data.Item.html">zebra.data.Item</a></li>
            
                <li><a href="../classes/zebra.data.ListModel.html">zebra.data.ListModel</a></li>
            
                <li><a href="../classes/zebra.data.Matrix.html">zebra.data.Matrix</a></li>
            
                <li><a href="../classes/zebra.data.SingleLineTxt.html">zebra.data.SingleLineTxt</a></li>
            
                <li><a href="../classes/zebra.data.Text.html">zebra.data.Text</a></li>
            
                <li><a href="../classes/zebra.data.TextModel.html">zebra.data.TextModel</a></li>
            
                <li><a href="../classes/zebra.data.TreeModel.html">zebra.data.TreeModel</a></li>
            
                <li><a href="../classes/zebra.Dummy.html">zebra.Dummy</a></li>
            
                <li><a href="../classes/zebra.forName().html">zebra.forName()</a></li>
            
                <li><a href="../classes/zebra.instanceOf().html">zebra.instanceOf()</a></li>
            
                <li><a href="../classes/zebra.Interface().html">zebra.Interface()</a></li>
            
                <li><a href="../classes/zebra.io.b64decode().html">zebra.io.b64decode()</a></li>
            
                <li><a href="../classes/zebra.io.b64encode().html">zebra.io.b64encode()</a></li>
            
                <li><a href="../classes/zebra.io.GET().html">zebra.io.GET()</a></li>
            
                <li><a href="../classes/zebra.io.HTTP.html">zebra.io.HTTP</a></li>
            
                <li><a href="../classes/zebra.io.ID().html">zebra.io.ID()</a></li>
            
                <li><a href="../classes/zebra.io.JRPC.html">zebra.io.JRPC</a></li>
            
                <li><a href="../classes/zebra.io.JRPC.invoke().html">zebra.io.JRPC.invoke()</a></li>
            
                <li><a href="../classes/zebra.io.POST().html">zebra.io.POST()</a></li>
            
                <li><a href="../classes/zebra.io.QS.html">zebra.io.QS</a></li>
            
                <li><a href="../classes/zebra.io.Service.html">zebra.io.Service</a></li>
            
                <li><a href="../classes/zebra.io.XRPC.html">zebra.io.XRPC</a></li>
            
                <li><a href="../classes/zebra.io.XRPC.invoke().html">zebra.io.XRPC.invoke()</a></li>
            
                <li><a href="../classes/zebra.layout.BorderLayout.html">zebra.layout.BorderLayout</a></li>
            
                <li><a href="../classes/zebra.layout.Constraints.html">zebra.layout.Constraints</a></li>
            
                <li><a href="../classes/zebra.layout.FlowLayout.html">zebra.layout.FlowLayout</a></li>
            
                <li><a href="../classes/zebra.layout.getAbsLocation().html">zebra.layout.getAbsLocation()</a></li>
            
                <li><a href="../classes/zebra.layout.getDirectAt().html">zebra.layout.getDirectAt()</a></li>
            
                <li><a href="../classes/zebra.layout.getDirectChild().html">zebra.layout.getDirectChild()</a></li>
            
                <li><a href="../classes/zebra.layout.getTopParent().html">zebra.layout.getTopParent()</a></li>
            
                <li><a href="../classes/zebra.layout.GridLayout.html">zebra.layout.GridLayout</a></li>
            
                <li><a href="../classes/zebra.layout.Layout.html">zebra.layout.Layout</a></li>
            
                <li><a href="../classes/zebra.layout.Layoutable.html">zebra.layout.Layoutable</a></li>
            
                <li><a href="../classes/zebra.layout.ListLayout.html">zebra.layout.ListLayout</a></li>
            
                <li><a href="../classes/zebra.layout.PercentLayout.html">zebra.layout.PercentLayout</a></li>
            
                <li><a href="../classes/zebra.layout.RasterLayout.html">zebra.layout.RasterLayout</a></li>
            
                <li><a href="../classes/zebra.layout.StackLayout.html">zebra.layout.StackLayout</a></li>
            
                <li><a href="../classes/zebra.ready().html">zebra.ready()</a></li>
            
                <li><a href="../classes/zebra.ui.BaseLayer.html">zebra.ui.BaseLayer</a></li>
            
                <li><a href="../classes/zebra.ui.BaseList.html">zebra.ui.BaseList</a></li>
            
                <li><a href="../classes/zebra.ui.BoldLabel.html">zebra.ui.BoldLabel</a></li>
            
                <li><a href="../classes/zebra.ui.Border.html">zebra.ui.Border</a></li>
            
                <li><a href="../classes/zebra.ui.BorderPan.html">zebra.ui.BorderPan</a></li>
            
                <li><a href="../classes/zebra.ui.Button.html">zebra.ui.Button</a></li>
            
                <li><a href="../classes/zebra.ui.Checkbox.html">zebra.ui.Checkbox</a></li>
            
                <li><a href="../classes/zebra.ui.Checkbox.Box.html">zebra.ui.Checkbox.Box</a></li>
            
                <li><a href="../classes/zebra.ui.ChildrenListener.html">zebra.ui.ChildrenListener</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.html">zebra.ui.Combo</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.ContentPan.html">zebra.ui.Combo.ContentPan</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.EditableContentPan.html">zebra.ui.Combo.EditableContentPan</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.ReadonlyContentPan.html">zebra.ui.Combo.ReadonlyContentPan</a></li>
            
                <li><a href="../classes/zebra.ui.ComboArrowView.html">zebra.ui.ComboArrowView</a></li>
            
                <li><a href="../classes/zebra.ui.CommandManager.html">zebra.ui.CommandManager</a></li>
            
                <li><a href="../classes/zebra.ui.CompList.html">zebra.ui.CompList</a></li>
            
                <li><a href="../classes/zebra.ui.ComponentListener.html">zebra.ui.ComponentListener</a></li>
            
                <li><a href="../classes/zebra.ui.Composite.html">zebra.ui.Composite</a></li>
            
                <li><a href="../classes/zebra.ui.CompositeView.html">zebra.ui.CompositeView</a></li>
            
                <li><a href="../classes/zebra.ui.CompRender.html">zebra.ui.CompRender</a></li>
            
                <li><a href="../classes/zebra.ui.CopyCutPaste.html">zebra.ui.CopyCutPaste</a></li>
            
                <li><a href="../classes/zebra.ui.Cursorable.html">zebra.ui.Cursorable</a></li>
            
                <li><a href="../classes/zebra.ui.CursorManager.html">zebra.ui.CursorManager</a></li>
            
                <li><a href="../classes/zebra.ui.designer.ShaperPan.html">zebra.ui.designer.ShaperPan</a></li>
            
                <li><a href="../classes/zebra.ui.Dotted.html">zebra.ui.Dotted</a></li>
            
                <li><a href="../classes/zebra.ui.Etched.html">zebra.ui.Etched</a></li>
            
                <li><a href="../classes/zebra.ui.EventManager.html">zebra.ui.EventManager</a></li>
            
                <li><a href="../classes/zebra.ui.findCanvas().html">zebra.ui.findCanvas()</a></li>
            
                <li><a href="../classes/zebra.ui.FocusListener.html">zebra.ui.FocusListener</a></li>
            
                <li><a href="../classes/zebra.ui.FocusManager.html">zebra.ui.FocusManager</a></li>
            
                <li><a href="../classes/zebra.ui.Font.html">zebra.ui.Font</a></li>
            
                <li><a href="../classes/zebra.ui.Gradient.html">zebra.ui.Gradient</a></li>
            
                <li><a href="../classes/zebra.ui.grid.DefEditors.html">zebra.ui.grid.DefEditors</a></li>
            
                <li><a href="../classes/zebra.ui.grid.Grid.html">zebra.ui.grid.Grid</a></li>
            
                <li><a href="../classes/zebra.ui.grid.GridCaption.html">zebra.ui.grid.GridCaption</a></li>
            
                <li><a href="../classes/zebra.ui.grid.GridStretchPan.html">zebra.ui.grid.GridStretchPan</a></li>
            
                <li><a href="../classes/zebra.ui.grid.Metrics.html">zebra.ui.grid.Metrics</a></li>
            
                <li><a href="../classes/zebra.ui.Group.html">zebra.ui.Group</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlElement.html">zebra.ui.HtmlElement</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlTextArea.html">zebra.ui.HtmlTextArea</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlTextField.html">zebra.ui.HtmlTextField</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlTextInput.html">zebra.ui.HtmlTextInput</a></li>
            
                <li><a href="../classes/zebra.ui.ImageLabel.html">zebra.ui.ImageLabel</a></li>
            
                <li><a href="../classes/zebra.ui.ImagePan.html">zebra.ui.ImagePan</a></li>
            
                <li><a href="../classes/zebra.ui.InputEvent.html">zebra.ui.InputEvent</a></li>
            
                <li><a href="../classes/zebra.ui.KeyEvent.html">zebra.ui.KeyEvent</a></li>
            
                <li><a href="../classes/zebra.ui.KeyListener.html">zebra.ui.KeyListener</a></li>
            
                <li><a href="../classes/zebra.ui.Label.html">zebra.ui.Label</a></li>
            
                <li><a href="../classes/zebra.ui.List.html">zebra.ui.List</a></li>
            
                <li><a href="../classes/zebra.ui.List.ViewProvider.html">zebra.ui.List.ViewProvider</a></li>
            
                <li><a href="../classes/zebra.ui.loadImage().html">zebra.ui.loadImage()</a></li>
            
                <li><a href="../classes/zebra.ui.Manager.html">zebra.ui.Manager</a></li>
            
                <li><a href="../classes/zebra.ui.Menu.html">zebra.ui.Menu</a></li>
            
                <li><a href="../classes/zebra.ui.Menunbar.html">zebra.ui.Menunbar</a></li>
            
                <li><a href="../classes/zebra.ui.MLabel.html">zebra.ui.MLabel</a></li>
            
                <li><a href="../classes/zebra.ui.MouseEvent.html">zebra.ui.MouseEvent</a></li>
            
                <li><a href="../classes/zebra.ui.MouseListener.html">zebra.ui.MouseListener</a></li>
            
                <li><a href="../classes/zebra.ui.MouseWheelSupport.html">zebra.ui.MouseWheelSupport</a></li>
            
                <li><a href="../classes/zebra.ui.PaintManager.html">zebra.ui.PaintManager</a></li>
            
                <li><a href="../classes/zebra.ui.PaintManImpl.html">zebra.ui.PaintManImpl</a></li>
            
                <li><a href="../classes/zebra.ui.Panel.html">zebra.ui.Panel</a></li>
            
                <li><a href="../classes/zebra.ui.PasswordText.html">zebra.ui.PasswordText</a></li>
            
                <li><a href="../classes/zebra.ui.Pattern.html">zebra.ui.Pattern</a></li>
            
                <li><a href="../classes/zebra.ui.Picture.html">zebra.ui.Picture</a></li>
            
                <li><a href="../classes/zebra.ui.PopupInfo.html">zebra.ui.PopupInfo</a></li>
            
                <li><a href="../classes/zebra.ui.PopupLayer.html">zebra.ui.PopupLayer</a></li>
            
                <li><a href="../classes/zebra.ui.PopupManager.html">zebra.ui.PopupManager</a></li>
            
                <li><a href="../classes/zebra.ui.Progress.html">zebra.ui.Progress</a></li>
            
                <li><a href="../classes/zebra.ui.Radial.html">zebra.ui.Radial</a></li>
            
                <li><a href="../classes/zebra.ui.Radiobox.html">zebra.ui.Radiobox</a></li>
            
                <li><a href="../classes/zebra.ui.RadioView.html">zebra.ui.RadioView</a></li>
            
                <li><a href="../classes/zebra.ui.Raised.html">zebra.ui.Raised</a></li>
            
                <li><a href="../classes/zebra.ui.Render.html">zebra.ui.Render</a></li>
            
                <li><a href="../classes/zebra.ui.RootLayer.html">zebra.ui.RootLayer</a></li>
            
                <li><a href="../classes/zebra.ui.RoundBorder.html">zebra.ui.RoundBorder</a></li>
            
                <li><a href="../classes/zebra.ui.Scroll.html">zebra.ui.Scroll</a></li>
            
                <li><a href="../classes/zebra.ui.ScrollManager.html">zebra.ui.ScrollManager</a></li>
            
                <li><a href="../classes/zebra.ui.ScrollPan.html">zebra.ui.ScrollPan</a></li>
            
                <li><a href="../classes/zebra.ui.Slider.html">zebra.ui.Slider</a></li>
            
                <li><a href="../classes/zebra.ui.SplitPan.html">zebra.ui.SplitPan</a></li>
            
                <li><a href="../classes/zebra.ui.StatePan.html">zebra.ui.StatePan</a></li>
            
                <li><a href="../classes/zebra.ui.Sunken.html">zebra.ui.Sunken</a></li>
            
                <li><a href="../classes/zebra.ui.SwitchManager.html">zebra.ui.SwitchManager</a></li>
            
                <li><a href="../classes/zebra.ui.Tabs.html">zebra.ui.Tabs</a></li>
            
                <li><a href="../classes/zebra.ui.TextArea.html">zebra.ui.TextArea</a></li>
            
                <li><a href="../classes/zebra.ui.TextField.html">zebra.ui.TextField</a></li>
            
                <li><a href="../classes/zebra.ui.TextRender.html">zebra.ui.TextRender</a></li>
            
                <li><a href="../classes/zebra.ui.Toolbar.html">zebra.ui.Toolbar</a></li>
            
                <li><a href="../classes/zebra.ui.TooltipInfo.html">zebra.ui.TooltipInfo</a></li>
            
                <li><a href="../classes/zebra.ui.TooltipManager.html">zebra.ui.TooltipManager</a></li>
            
                <li><a href="../classes/zebra.ui.tree.DefEditors.html">zebra.ui.tree.DefEditors</a></li>
            
                <li><a href="../classes/zebra.ui.tree.DefViews.html">zebra.ui.tree.DefViews</a></li>
            
                <li><a href="../classes/zebra.ui.tree.Tree.html">zebra.ui.tree.Tree</a></li>
            
                <li><a href="../classes/zebra.ui.View.html">zebra.ui.View</a></li>
            
                <li><a href="../classes/zebra.ui.ViewPan.html">zebra.ui.ViewPan</a></li>
            
                <li><a href="../classes/zebra.ui.ViewSet.html">zebra.ui.ViewSet</a></li>
            
                <li><a href="../classes/zebra.ui.Window.html">zebra.ui.Window</a></li>
            
                <li><a href="../classes/zebra.ui.WinLayer.html">zebra.ui.WinLayer</a></li>
            
                <li><a href="../classes/zebra.ui.WinListener.html">zebra.ui.WinListener</a></li>
            
                <li><a href="../classes/zebra.ui.zCanvas.html">zebra.ui.zCanvas</a></li>
            
                <li><a href="../classes/zebra.URL.html">zebra.URL</a></li>
            
                <li><a href="../classes/zebra.util.Bag.html">zebra.util.Bag</a></li>
            
                <li><a href="../classes/zebra.util.findInTree().html">zebra.util.findInTree()</a></li>
            
                <li><a href="../classes/zebra.util.Listeners.html">zebra.util.Listeners</a></li>
            
                <li><a href="../classes/zebra.util.newInstance().html">zebra.util.newInstance()</a></li>
            
                <li><a href="../classes/zebra.util.Position.html">zebra.util.Position</a></li>
            
                <li><a href="../classes/zebra.util.Position.Metric.html">zebra.util.Position.Metric</a></li>
            
                <li><a href="../classes/zebra.util.rgb.html">zebra.util.rgb</a></li>
            
        </ul>
    </div>
</div>












        </div>

        <div id="main" class="yui3-u">
            <div class="content"><h4>ui.window.js</h4>

<pre class="code prettyprint linenums">
(function(pkg, Class, Interface) {

/**
 * @module ui
 * @namespace zebra.ui
 */


/**
 * Toltip interface. The interface is supposed to be used to say 
 * which component has to be shown as a tooltip at the given location of 
 * the UI component.
 * @class TooltipInfo
 * @interface
 */
pkg.TooltipInfo = Interface();
/**
 * Get an UI component to be shown as a tooltip for the given UI
 * component at the given location of the target component 
 * @param {zebra.ui.Panel} target a target UI component
 * @param {Integer} x a x coordinate relatively to the target UI component
 * @param {Integer} x a y coordinate relatively to the target UI component
 * @return {zebra.ui.Panel} an UI component to be shown as tooltip
 * @method getTooltip
 */


/**
 * Popup interface to indicate which UI component has to be shown at the 
 * given location of the UI component as a popup menu.
 * @class PopupInfo
 * @interface
 */
pkg.PopupInfo = Interface();
/**
 * Get an UI component to be shown as a popup menu for the given UI
 * component at the given location of the target component 
 * @param {zebra.ui.Panel} target a target UI component
 * @param {Integer} x a x coordinate relatively to the target UI component
 * @param {Integer} x a y coordinate relatively to the target UI component
 * @return {zebra.ui.Panel} an UI component to be shown as popup menu UI component
 * @method getPopup
 */


/**
 * Window listener interface
 * @class WinListener
 * @interface
 */
pkg.WinListener = Interface();
/**
 * Fire when an UI component has been opened or closed on the given window layer 
 * @param {zebra.ui.BaseLayer} winLayer a win layer where the window component is hosted
 * @param {zebra.ui.Panel} win an UI component that is used as the window
 * @param {Boolean} status a status of the window component. true means the window component 
 * has been opened, false means the window component has been closed
 * @method winOpened
 */

/**
 * Fire when an UI component has been activated or deactivate on the given window layer 
 * @param {zebra.ui.BaseLayer} winLayer a win layer where the window component is hosted
 * @param {zebra.ui.Panel} win an UI component that is used as the window
 * @param {Boolean} status a status of the window component. true means the window component 
 * has been activated, false means the window component has been deactivated
 * @method winActivated
 */


var KE = pkg.KeyEvent, timer = zebra.util.timer, L = zebra.layout, MouseEvent = pkg.MouseEvent,
    WIN_OPENED = 1, WIN_CLOSED = 2, WIN_ACTIVATED = 3, WIN_DEACTIVATED = 4, VIS_PART_SIZE = 30,
    WinListeners = zebra.util.Listeners.Class(&quot;winOpened&quot;, &quot;winActivated&quot;);

pkg.showModalWindow = function(context, win, listener) {
    pkg.showModalWindow(context, &quot;modal&quot;, win, listener);
};

pkg.showWindow = function(context, type, win, listener) {
    if (arguments.length &lt; 3) {
        win = type;
        type = &quot;info&quot;;
    }
    return pkg.findCanvas(context).getLayer(&quot;win&quot;).addWin(type, win, listener);
};

pkg.hideWindow = function(win) {
    if (win.parent &amp;&amp; win.parent.indexOf(win) &gt;=0) {
        win.parent.remove(win);
    }
};

/**
 * Window layer class. Window layer is supposed to be used for showing
 * modal and none modal internal window. There are special ready to use 
 * &quot;zebra.ui.Window&quot; UI component that can be shown as internal window, but
 * zebra allows developers to show any UI component as modal or none modal 
 * window. Add an UI component to window layer to show it as modal o none 
 * modal window:
 
        // create canvas
        var canvas   = new zebra.ui.zCanvas();
       
        // get windows layer 
        var winLayer = canvas.getLayer(zebra.ui.WinLayer.ID);

        // create standard UI window component 
        var win = new zebra.ui.Window();
        win.setBounds(10,10,200,200);

        // show the created window as modal window
        winLayer.addWin(&quot;modal&quot;, win);

 * Also shortcut method can be used
 
        // create canvas
        var canvas   = new zebra.ui.zCanvas();

        // create standard UI window component 
        var win = new zebra.ui.Window();
        win.setBounds(10,10,200,200);

        // show the created window as modal window
        zebra.ui.showModalWindow(canvas, win);

 * Window layer supports three types of windows:
 
    - **&quot;modal&quot;** a modal window catches all input till it will be closed 
    - **&quot;mdi&quot;** a MDI window can get focus, but it doesn&#x27;t block switching 
    focus to other UI elements
    - **&quot;info&quot;** an INFO window cannot get focus. It is supposed to show 
    some information like tooltip.

 * @class WinLayer
 * @constructor
 * @extends {zebra.ui.BaseLayer}
 */
pkg.WinLayer = Class(pkg.BaseLayer, pkg.ChildrenListener, [
    function $clazz() {
        this.ID = &quot;win&quot;;
    },

    function $prototype() {
        this.isLayerActive  = function() {
            return this.activeWin != null;
        };

        this.layerMousePressed = function(x,y,mask){
            var cnt = this.kids.length;
            if (cnt &gt; 0) {
                if (this.activeWin != null &amp;&amp; this.indexOf(this.activeWin) == cnt - 1){
                    var x1 = this.activeWin.x,
                        y1 = this.activeWin.y,
                        x2 = x1 + this.activeWin.width,
                        y2 = y1 + this.activeWin.height;

                    if (x &gt;= x1 &amp;&amp; y &gt;= y1 &amp;&amp; x &lt; x2 &amp;&amp; y &lt; y2) return;
                }

                for(var i = cnt - 1; i &gt;= 0 &amp;&amp; i &gt;= this.topModalIndex; i--){
                    var d = this.kids[i];
                    if (d.isVisible &amp;&amp; d.isEnabled &amp;&amp; this.winType(d) != &quot;info&quot; &amp;&amp;
                        x &gt;= d.x &amp;&amp; y &gt;= d.y &amp;&amp; x &lt; d.x + d.width &amp;&amp; y &lt; d.y + d.height)
                    {
                        this.activate(d);
                        return;
                    }
                }

                if (this.topModalIndex &lt; 0 &amp;&amp; this.activeWin != null) {
                    this.activate(null);
                }
            }
        };

        this.layerKeyPressed = function(keyCode,mask){
            if(this.kids.length &gt; 0 &amp;&amp; keyCode == KE.TAB &amp;&amp; (mask &amp; KE.M_SHIFT) &gt; 0){
                if (this.activeWin == null) this.activate(this.kids[this.kids.length - 1]);
                else {
                    var winIndex = this.winsStack.indexOf(this.activeWin) - 1;
                    if (winIndex &lt; this.topModalIndex || winIndex &lt; 0) {
                        winIndex = this.winsStack.length - 1;
                    }
                    this.activate(this.winsStack[winIndex]);
                }
            }
        };

        this.childInputEvent = function (e) {
            if (e.ID == pkg.InputEvent.FOCUS_GAINED) {
                this.activate(L.getDirectChild(this, e.source));
            }
        };

        this.getComponentAt = function(x,y){
            return (this.activeWin == null) ? null
                                            : this.activeWin.getComponentAt(x - this.activeWin.x,
                                                                            y - this.activeWin.y);
        };

        this.getFocusRoot = function(){ return this.activeWin; };

        this.winType = function(w) { return this.winsInfo[w][1]; };

        /**
         * Activate the given win layer children component window. 
         * @param  {zebra.ui.Panel} c a component to be activated as window
         * @method activate
         */
        this.activate = function(c){
            if (c != null &amp;&amp; (this.winsInfo.hasOwnProperty(c) === false ||
                              this.winType(c) == &quot;info&quot;))
            {
                throw new Error();
            }

            if (c != this.activeWin) {
                var old = this.activeWin;
                if (c == null) {
                    if (this.winType(this.activeWin) == &quot;modal&quot;) throw new Error();
                    this.activeWin = null;
                    this.fire(WIN_DEACTIVATED, old);
                    pkg.focusManager.requestFocus(null);
                }
                else {
                    if (this.winsStack.indexOf(c) &lt; this.topModalIndex) throw new Error();
                    this.activeWin = c;
                    this.toFront(this.activeWin);
                    if (old != null) this.fire(WIN_DEACTIVATED, old);
                    this.fire(WIN_ACTIVATED, this.activeWin);
                    this.activeWin.validate();
                    pkg.focusManager.requestFocus(pkg.focusManager.findFocusable(this.activeWin));
                }
            }
        };

        this.fire = function(id, win, l) {
            if (arguments.length &lt; 3) {
                l = this.winsInfo[win][2];
            }

            var b = (id == WIN_OPENED || id == WIN_ACTIVATED),
                n = (id == WIN_OPENED || id == WIN_CLOSED) ? &quot;winOpened&quot; : &quot;winActivated&quot;;

            this._[n](this, win, b);
            if (zebra.instanceOf(win, pkg.WinListener)) win[n].apply(win, [this, win, b]);
            if (l != null) l[n].apply(l, [this, win, b]);
        };

        /**
         * Add the given window with the given type and the listener to the layer.  
         * @param {String} type   a type of the window: &quot;modal&quot;, 
         * &quot;mdi&quot; or &quot;info&quot;
         * @param {zebra.ui.Panel} win an UI component to be shown as window
         * @param {zebra.ui.WinListener} [listener] an optional the window listener 
         * @method addWin 
         */
        this.addWin = function(type, win, listener) {
            this.winsInfo[win] = [ this.activeWin, type, listener ];
            this.add(win);
        };
    },

    function () {
        /**
         * Currently activated as a window children component
         * @attribute activeWin
         * @type {zebra.ui.Panel}
         * @readOnly
         * @protected
         */
        this.activeWin = null;
        this.topModalIndex = -1;
        this.winsInfo  = {};
        this.winsStack = [];
        this._ = new WinListeners();
        this.$super(pkg.WinLayer.ID);
    },

    function insert(index, constr, lw) {
        var info = this.winsInfo[lw];
        if (typeof info === &#x27;undefined&#x27;) {
            info = [this.activeWin, &quot;mdi&quot;, null];
            this.winsInfo[lw] = info;
        }
        if (info[1] != &quot;mdi&quot; &amp;&amp; info[1] != &quot;modal&quot; &amp;&amp; info[1] != &quot;info&quot;) {
            throw new Error();
        }
        return this.$super(index, constr, lw);
    },

    function kidAdded(index,constr,lw){
        this.$super(index, constr, lw);
        var info = this.winsInfo[lw];
        this.winsStack.push(lw);
        if (info[1] == &quot;modal&quot;) this.topModalIndex = this.winsStack.length - 1;
        this.fire(WIN_OPENED, lw);
        if (info[1] == &quot;modal&quot;) this.activate(lw);
    },

    function kidRemoved(index,lw){
        this.$super(this.kidRemoved,index, lw);
        if (this.activeWin == lw){
            this.activeWin = null;
            pkg.focusManager.requestFocus(null);
        }
        var ci = this.winsStack.indexOf(lw), l = this.winsInfo[lw][2];
        delete this.winsInfo[lw];
        this.winsStack.splice(this.winsStack.indexOf(lw), 1);
        if (ci &lt; this.topModalIndex) this.topModalIndex--;
        else {
            if (this.topModalIndex == ci){
                for(this.topModalIndex = this.kids.length - 1;this.topModalIndex &gt;= 0; this.topModalIndex--){
                    if (this.winType(this.winsStack[this.topModalIndex]) == &quot;modal&quot;) break;
                }
            }
        }

        this.fire(WIN_CLOSED, lw, l);
        if(this.topModalIndex &gt;= 0){
            var aindex = this.winsStack.length - 1;
            while(this.winType(this.winsStack[aindex]) == &quot;info&quot;) aindex--;
            this.activate(this.winsStack[aindex]);
        }
    }
]);

// !!!!!
// this code can be generalized to other cases and UI components
// !!!!!
var $StatePan = Class(pkg.Panel, [
    function $prototype() {
        this.setState = function(s) {
            if (this.state != s) {
                var old = this.state;
                this.state = s;
                this.updateState(old, s);
            }
        };

        this.updateState = function(olds, news) {
            var b = false;
            if (this.bg &amp;&amp; this.bg.activate)  b = this.bg.activate(news);
            if (this.border &amp;&amp; this.border.activate) b = this.border.activate(news) || b;
            if (b) this.repaint();
        };
    },

    function() {
        this.state = &quot;inactive&quot;;
        this.$super();
    },

    function setBorder(v) {
        this.$super(v);
        this.updateState(this.state, this.state);
    },

    function setBackground(v) {
        this.$super(v);
        this.updateState(this.state, this.state);
    }
]);

/**
 * Window UI component class. Implements window like UI component.
 * The window component has a header, status bar and content areas. The header component  
 * is usually placed at the top of window, the status bar component is placed at the bottom and
 * the content component at places the central part of the window. Also the window defines 
 * corner UI component that is supposed to be used to resize the window. The window implementation 
 * provides the following possibilities: 
 
    - Move window by dragging the window on its header 
    - Resize window by dragging the window corner element
    - Place buttons in the header to maximize, minimize, close, etc the window
    - Indicates state of window (active or inactive) by changing 
    the widow header style 
    - Define a window icon component
    - Define a window status bar component

 * @class Window
 * @extends {zebra.ui.Panel}
 */
pkg.Window = Class($StatePan, pkg.WinListener,
                   pkg.MouseListener, pkg.Composite, 
                   pkg.Cursorable, pkg.ExternalEditor, [

    function $prototype() {
        var MOVE_ACTION = 1, SIZE_ACTION = 2;

        /**
         * Minimal possible size of the window
         * @default 40
         * @attribute minSize
         * @type {Integer}
         */
        this.minSize = 40;

        /**
         * Indicate if the window can be resized by dragging its by corner 
         * @attribute isSizeable
         * @type {Boolean}
         * @default true
         * @readOnly
         */
        this.isSizeable = true;

        this.mouseDragStarted = function(e){
            this.px = e.x;
            this.py = e.y;
            this.psw = this.width;
            this.psh = this.height;
            this.action = this.insideCorner(this.px, this.py) ? (this.isSizeable ? SIZE_ACTION : -1): MOVE_ACTION;
            if (this.action &gt; 0) this.dy = this.dx = 0;
        };

        this.mouseDragged = function(e){
            if (this.action &gt; 0){
                if (this.action != MOVE_ACTION){
                    var nw = this.psw + this.dx, nh = this.psh + this.dy;
                    if(nw &gt; this.minSize &amp;&amp; nh &gt; this.minSize) this.setSize(nw, nh);
                }
                this.dx = (e.x - this.px);
                this.dy = (e.y - this.py);
                if (this.action == MOVE_ACTION){
                    this.invalidate();
                    this.setLocation(this.x + this.dx, this.y + this.dy);
                }
            }
        };

        this.mouseDragEnded = function(e){
            if (this.action &gt; 0){
                if (this.action == MOVE_ACTION){
                    this.invalidate();
                    this.setLocation(this.x + this.dx, this.y + this.dy);
                }
                this.action = -1;
            }
        };

        /**
         * Test if the mouse cursor is inside the window corner component
         * @protected 
         * @param  {Integer} px a x coordinate of the mouse cursor 
         * @param  {Integer} py a y coordinate of the mouse cursor 
         * @return {[type]}  true if the mouse cursor is inside window 
         * corner component
         * @method insideCorner
         */
        this.insideCorner = function(px,py){
            return this.getComponentAt(px, py) == this.sizer;
        };

        this.getCursorType = function(target,x,y){
            return (this.isSizeable &amp;&amp; this.insideCorner(x, y)) ? pkg.Cursor.SE_RESIZE : -1;
        };

        this.catchInput = function(c){
            var tp = this.caption;
            return c == tp || (L.isAncestorOf(tp, c) &amp;&amp; zebra.instanceOf(c, pkg.Button) === false) ||
                   this.sizer== c;
        };

        this.winOpened = function(winLayer,target,b) {
            var state = b?&quot;active&quot;:&quot;inactive&quot;;
            if (this.caption != null &amp;&amp; this.caption.setState) {
                this.caption.setState(state);
            }
            this.setState(state);
        };

        this.winActivated = function(winLayer, target,b){
            this.winOpened(winLayer, target,b);
        };

        this.mouseClicked= function (e){
            var x = e.x, y = e.y, cc = this.caption;
            if (e.clicks == 2 &amp;&amp; this.isSizeable &amp;&amp; x &gt; cc.x &amp;&amp;
                x &lt; cc.y + cc.width &amp;&amp; y &gt; cc.y &amp;&amp; y &lt; cc.y + cc.height)
            {
                if(this.prevW &lt; 0) this.maximize();
                else this.restore();
            }
        };

        this.isMaximized = function() { return this.prevW != -1; };
    },

    function $clazz() {
        this.CaptionPan = Class($StatePan, []);
        this.TitleLab   = Class(pkg.Label, []);
        this.StatusPan  = Class(pkg.Panel, []);
        this.ContentPan = Class(pkg.Panel, []);
        this.SizerIcon  = Class(pkg.ImagePan, []);
        this.Icon       = Class(pkg.ImagePan, []);
        this.Button     = Class(pkg.Button, []);
    },

    function () {  this.$this(&quot;&quot;);  },

    function (s){
        //!!! for some reason state has to be set beforehand
        this.state = &quot;inactive&quot;;

        this.prevH = this.prevX = this.prevY = this.psw = this.psh = this.px = this.py = this.dx = this.dy = 0;
        this.prevW = this.action = -1;

        this.root    = new pkg.Window.ContentPan();
        this.caption = new pkg.Window.CaptionPan();
        this.title   = new pkg.Window.TitleLab(s);

        var icons = new pkg.Panel(new L.FlowLayout(L.LEFT, L.CENTER, L.HORIZONTAL, 2));
        this.buttons = new pkg.Panel(new L.FlowLayout(L.CENTER, L.CENTER)),

        icons.add(new pkg.Window.Icon());
        icons.add(this.title);

        this.caption.add(L.LEFT, icons);
        this.caption.add(L.RIGHT, this.buttons);

        this.status = new pkg.Window.StatusPan();
        this.sizer  = new pkg.Window.SizerIcon();
        this.status.add(this.sizer);

        this.setSizeable(true);

        this.$super(new L.BorderLayout(2,2));

        this.add(L.CENTER, this.root);
        this.add(L.TOP, this.caption);
        this.add(L.BOTTOM, this.status);
    },

    function fired(src) { this.parent.remove(this); },

    function focused(){
        this.$super();
        if (this.caption != null) this.caption.repaint();
    },

    /**
     * Make the window sizeable or not sizeable
     * @param {Boolean} b a sizeable state of the window
     * @method setSizeable
     */
    function setSizeable(b){
        if (this.isSizeable != b){
            this.isSizeable = b;
            if (this.sizer != null) this.sizer.setVisible(b);
        }
    },

    /**
     * Maximize the window
     * @method maximize 
     */
    function maximize(){
        if(this.prevW &lt; 0){
            var d = pkg.findCanvas(this), left = d.getLeft(), top = d.getTop();
            this.prevX = this.x;
            this.prevY = this.y;
            this.prevW = this.width;
            this.prevH = this.height;
            this.setLocation(left, top);
            this.setSize(d.width - left - d.getRight(), d.height - top - d.getBottom());
        }
    },

    /**
     * Restore the window size
     * @method restore
     */
    function restore(){
        if (this.prevW &gt;= 0){
            this.setLocation(this.prevX, this.prevY);
            this.setSize(this.prevW, this.prevH);
            this.prevW = -1;
        }
    },

    /**
     * Close the window
     * @method close
     */
    function close() {
        if (this.parent) this.parent.remove(this);
    },

    /**
     * Set the window buttons set.
     * @param {Object} buttons dictionary of buttons icons for window buttons. 
     * The dictionary key defines a method of the window component to be called 
     * when the given button has been pressed. So the method has to be defined
     * in the window component.
     * @method setButtons
     */
    function setButtons(buttons) {
        // remove previously added buttons
        for(var i=0; i&lt; this.buttons.length; i++) {
            var kid = this.buttons.kids[i];
            if (kid._) kid._.removeAll();
        }
        this.buttons.removeAll();

        // add new buttons set
        for(var k in buttons) {
            if (buttons.hasOwnProperty(k)) {
                var b = new pkg.Window.Button(), bv = buttons[k];
                b.setView(bv);
                this.buttons.add(b);
                (function(t, f) {
                    b._.add(function() { f.call(t); });
                })(this, this[k]);
            }
        }
    }
]);

/**
 * Tooltip manager class implements possibility to define a tooltip 
 * for a component. Tooltip is an UI component that has to be shown 
 * as information window every time a mouse cursor has entered the
 * specified component of the given area of the specified component.
 * @class TooltipManager
 * @extends zebra.ui.Manager
 * @constructor 
 */
pkg.TooltipManager = Class(pkg.Manager, pkg.MouseListener, [
    function $clazz() {
        this.Label = Class(pkg.Label, []);

        this.createTooltip = function(text){
            var lab = new pkg.TooltipManager.Label(new zebra.data.Text(text));
            lab.toPreferredSize();
            return lab;
        };
    },

    function $prototype() {
        var TI = pkg.TooltipInfo;


        /**
         * Indicates if a shown tooltip has to disappear by mouse pressed event 
         * @attribute stopByPress
         * @type {Boolean}
         * @default true
         */
        this.stopByPress = true;

        this.mouseEntered = function(e){
            var c = e.source;
            if (zebra.instanceOf(c, TI) || this.tooltips[c]){
                this.target = c;
                this.targetLayer = pkg.findCanvas(c).getLayer(pkg.WinLayer.ID);
                this.x = e.x;
                this.y = e.y;
                timer.start(this, this.tick, this.tick);
            }
        };

        this.mouseExited = function(e){
            if (this.target != null){
                timer.stop(this);
                this.target = null;
                this.hideTooltipInfo();
            }
        };

        this.mouseMoved = function(e){
            if (this.target != null){
                timer.clear(this);
                this.x = e.x;
                this.y = e.y;
                this.hideTooltipInfo();
            }
        };

        this.run = function(){
            if (this.tooltip == null){
                var tp = this.tooltips[this.target];
                if (!tp) tp = null;
                if (tp == null &amp;&amp; zebra.instanceOf(this.target, TI)) tp = this.target;
                this.tooltip = zebra.instanceOf(tp, TI) ? tp.getTooltip(this.target, this.x, this.y) : tp;
                if (this.tooltip != null) {
                    var p = L.getAbsLocation(this.x, this.y, this.target);
                    this.tooltip.toPreferredSize();
                    var tx = p[0], ty = p[1] - this.tooltip.height, dw = this.targetLayer.width;
                    if (tx + this.tooltip.width &gt; dw) tx = dw - this.tooltip.width - 1;
                    this.tooltip.setLocation(tx &lt; 0 ? 0 : tx, ty &lt; 0 ? 0 : ty);
                    this.targetLayer.addWin(&quot;info&quot;, this.tooltip, null);
                }
            }
        };

        /**
         * Hide tooltip if it has been shown
         * @method hideTooltipInfo
         */
        this.hideTooltipInfo = function(){
            if(this.tooltip != null){
                this.targetLayer.remove(this.tooltip);
                this.tooltip = null;
            }
        };

        /**
         * Bind or unbind the given UI component with the specified tooltip component 
         * @param {zebra.ui.Panel} an component for that a tooltip has to be shown
         * @param {zebra.ui.Panel|String} a tooltip to be shown. You can pass string 
         * or an UI component to be shown as the tooltip. String will be transformed 
         * into a tooltip UI label component.  Pass null as the argument to stop
         * showing tooltip for the given component.
         * @method setTooltip
         */
        this.setTooltip = function (c,data){
            if (data != null) this.tooltips[c] = zebra.isString(data) ? pkg.TooltipManager.createTooltip(data) : data;
            else {
                if (this.target == c){
                    timer.stop(this);
                    this.target = null;
                    this.hideTooltipInfo();
                }
                delete this.tooltips[c];
            }
        };

        this.mousePressed = function(e){
            if (this.stopByPress &amp;&amp; this.target != null){
                timer.stop(this);
                this.target = null;
                this.hideTooltipInfo();
            }
        };

        this.mouseReleased = function(e){
            if (this.stopByPress &amp;&amp; this.target != null){
                this.x = e.x;
                this.y = e.y;
                timer.start(this, this.tick, this.tick);
            }
        };
    },

    function(){
        this.$super();
        this.tooltips = {};
        this.x = this.y = 0;
        this.targetLayer = this.tooltip = this.target = null;

        /**
         * Define interval (in milliseconds) between entering a component and showing 
         * a tooltip for the entered component 
         * @attribute tick
         * @type {Integer}
         */
        this.tick = 400;
    }
]);

/**
 * Menu UI component class. The class implements popup menu UI component. 
 * 
 * @class Menu
 * @constructor
 * @param {Object} [list] use special notation to define a menu
 
        {
            &#x27;Menu Item 1&#x27;: null,   // menu item 1 without a sub menu
            &#x27;Menu Item 2&#x27;: null,   // menu item 2 without a sub menu
            &#x27;-&#x27;:null,              // decorative line element 
            &#x27;Menu Item 3&#x27;: {       // menu item 3 with a sub menu defined
                &quot;[x] Checkable menu item&quot;:null, // checkable menu item
                &quot;Sub item 1&quot;:null
            }
        }


 * @extends {zebra.ui.CompList}
 */
pkg.Menu = Class(pkg.CompList, pkg.ChildrenListener, [
    function $prototype() {
        /**
         * Test if the given menu item is a decorative (not selectable) menu item 
         * @param  {Integer}  index a menu item index
         * @return {Boolean}  true if the given menu item is decorative 
         * @method isDecorative
         */
        this.isDecorative = function(index){
            return zebra.instanceOf(this.kids[index], pkg.Menu.ItemPan) === false;
        };

        this.canHaveFocus = function() { return true; };

        this.childCompEvent = function(id, src, p1, p2){
            if(id == pkg.ComponentListener.SHOWN ||
               id == pkg.ComponentListener.ENABLED)
            {
                for(var i = 0;i &lt; this.kids.length; i++){
                    if (this.kids[i].content == src) {
                        var ccc = this.kids[i];
                        ccc.setVisible(src.isVisible);
                        ccc.setEnabled(src.isEnabled);
                        if (i &gt; 0 &amp;&amp; this.isDecorative(i - 1)) this.kids[i - 1].setVisible(src.isVisible);
                        break;
                    }
                }
            }
        };

        this.hasVisibleItems = function(){
            for(var i = 0;i &lt; this.kids.length; i++) if (this.kids[i].isVisible) return true;
            return false;
        };

        this.update = function (g){
            if (this.views[&quot;marker&quot;] != null &amp;&amp; this.hasFocus()){
                var gap = this.getItemGap(), offset = this.position.offset;
                if(offset &gt;= 0 &amp;&amp; !this.isDecorative(offset)){
                    var is = this.getItemSize(offset), l = this.getItemLocation(offset);
                    this.views[&quot;marker&quot;].paint(g, l.x - gap, l.y - gap, is.width + 2 * gap, is.height + 2 * gap, this);
                }
            }
        };

        this.mouseExited = function(e){
            var offset = this.position.offset;
            if (offset &gt;= 0 &amp;&amp; this.getSubmenuAt(offset) == null) {
                this.position.clearPos();
            }
        };

        this.drawPosMarker = function(g,x,y,w,h){};

        this.keyPressed = function(e){
            var position = this.position;

            if(position.metrics.getMaxOffset() &gt;= 0){
                var code = e.code, offset = position.offset;
                if (code == KE.DOWN) {
                    var ccc = this.kids.length;
                    do { offset = (offset + 1) % ccc; }
                    while(this.isDecorative(offset));
                    position.setOffset(offset);
                }
                else {
                    if (code == KE.UP) {
                        var ccc = this.kids.length;
                        do { offset = (ccc + offset - 1) % ccc; }
                        while(this.isDecorative(offset));
                        position.setOffset(offset);
                    }
                    else {
                        if (e.code == KE.ENTER || e.code == KE.SPACE) this.select(offset);
                    }
                }
            }
        };

        /**
         * Get a sub menu for the given menu item 
         * @param  {Integer} index a menu item index
         * @return {zebra.ui.Menu} a sub menu or null if no sub menu 
         * is defined for the given menu item 
         * @method getSubmenuAt
         */
        this.getSubmenuAt = function(index){
            return this.menus[this.kids[index]];
        };

        /**
         * Set the given menu as a sub-menu for the specified menu item
         * @param {Inetger} i an index of a menu item for that a sub menu has to be attached
         * @param {zebra.ui.Menu} m a sub menu to be attached
         * @method setSubmenuAt
         */
        this.setSubmenuAt = function (i, m){
            if (m == this || this.isDecorative(i)) throw new Error();
            var p = this.kids[i], sub = this.menus[p];
            this.menus[p] = m;

            if(m != null){
                if (sub == null) {
                    p.set(L.RIGHT, new pkg.Menu.SubImage());
                }
            }
            else {
                if (sub != null) p.set(L.RIGHT, null);
            }
        };
    },

    function $clazz() {
        this.Label = Class(pkg.Label, []);
        this.CheckStatePan = Class(pkg.ViewPan, []);

        this.ItemPan = Class(pkg.Panel, [
            function $prototype() {
                this.gap = 8;

                this.selected = function() {
                    if (this.content.setState) {
                        this.content.setState(!this.content.getState());
                    }
                };

                this.calcPreferredSize = function (target){
                    var cc = 0, pw = 0, ph = 0;

                    for(var i=0; i &lt; target.kids.length; i++) {
                        var k = target.kids[i];
                        if (k.isVisible) {
                            var ps = k.getPreferredSize();
                            pw += ps.width + (cc &gt; 0 ? this.gap : 0);
                            if (ps.height &gt; ph) ph = ps.height;
                            cc ++;
                        }
                    }

                    return { width:pw, height:ph };
                };

                this.doLayout = function(target){
                    var mw = -1;

                    // calculate icons area maximal width
                    for(var i=0; i &lt; target.parent.kids.length; i++) {
                        var k = target.parent.kids[i];
                        if (k.isVisible &amp;&amp; zebra.instanceOf(k, pkg.Menu.ItemPan)) {
                            var l = k.getByConstraints(L.LEFT);
                            if (l &amp;&amp; l.isVisible) {
                                var ps = l.getPreferredSize();
                                if (ps.width &gt; mw) mw = ps.width;
                            }
                        }
                    }

                    var left    = target.getByConstraints(L.LEFT),
                        right   = target.getByConstraints(L.RIGHT),
                        content = target.getByConstraints(L.CENTER),
                        t = target.getTop(), eh = target.height - t - target.getBottom();

                    if (left &amp;&amp; left.isVisible) {
                        left.toPreferredSize();
                        left.setLocation(this.getLeft(), t + (eh - left.height)/2);
                    }

                    if (content &amp;&amp; content.isVisible) {
                        content.toPreferredSize();
                        content.setLocation(target.getLeft() + (mw &gt;= 0 ? mw + this.gap : 0), t + (eh - content.height)/2);
                    }

                    if (right &amp;&amp; right.isVisible) {
                        right.toPreferredSize();
                        right.setLocation(target.width - target.getLeft() - right.width, t + (eh - right.height)/2);
                    }
                };
            },

            function (c) {
                this.$super();
                this.content = c;
                this.add(L.CENTER, c);
                this.setEnabled(c.isEnabled);
                this.setVisible(c.isVisible);
            }
        ]);

        this.ChItemPan = Class(this.ItemPan, [
            function (c, state) {
                this.$super(c);
                this.add(L.LEFT, new pkg.Menu.CheckStatePan());
                this.state = state;
            },

            function selected() {
                this.$super();
                this.state = !this.state;
                this.getByConstraints(L.LEFT).view.activate(this.state ? &quot;on&quot; : &quot;off&quot;);
            }
        ]);

        this.Line     = Class(pkg.Line,     []);
        this.SubImage = Class(pkg.ImagePan, []);
    },

    function (){
        this.menus = {};
        this.$super(true);
    },

    function (d){
        this.$this();
        for(var k in d) {
            if (d.hasOwnProperty(k)) {
                this.add(k);
                if (d[k]) {
                    this.setSubmenuAt(this.kids.length-1, new pkg.Menu(d[k]));
                }
            }
        }
    },

    function insert(i, ctr, c) {
        if (zebra.isString(c)) {
            if (c == &#x27;-&#x27;) return this.$super(i, ctr, new pkg.Menu.Line());
            else {
                var m = c.match(/(\[\s*\]|\[x\]|\(x\)|\(\s*\))?\s*(.*)/);
                if (m != null &amp;&amp; m[1] != null) {
                    return this.$super(i, ctr, new pkg.Menu.ChItemPan(new pkg.Menu.Label(m[2]), m[1].indexOf(&#x27;x&#x27;) &gt; 0));
                }
                c = new pkg.Menu.Label(c);
            }
        }
        return this.$super(i, ctr, new pkg.Menu.ItemPan(c));
    },

    /**
     * Add the specified component as a decorative item of the menu
     * @param {zebra.ui.Panel} c an UI component 
     * @method addDecorative
     */
    function addDecorative(c) {
        this.$super(this.insert, this.kids.length, null, c);
    },

    function kidRemoved(i,c){
        this.setSubmenuAt(i, null);
        this.$super(i, c);
    },

    function posChanged(target,prevOffset,prevLine,prevCol){
        var off = this.position.offset;
        if (off &lt; 0 || (this.kids.length &gt; 0 &amp;&amp; this.kids[off].isVisible)){
            this.$super(target, prevOffset, prevLine, prevCol);
        }
        else {
            var d = (prevOffset &lt; off) ? 1 : -1, cc = this.kids.length, ccc = cc;
            for(; cc &gt; 0 &amp;&amp; (this.kids[off].isVisible === false || this.isDecorative(off)); cc--){
                off += d;
                if (off &lt; 0) off = ccc - 1;
                if (off &gt;= ccc) off = 0;
            }

            if (cc &gt; 0){
                this.position.setOffset(off);
                this.repaint();
            }
        }
    },

    function select(i) {
        if (i &lt; 0 || this.isDecorative(i) === false) {
            if (i &gt;= 0) {
                if (this.kids[i].content.isEnabled === false) return;
                this.kids[i].selected();
            }
            this.$super(i);
        }
    }
]);

/**
 * Menu bar UI component class. Menu bar can be build in any part of UI application.
 * There is no restriction regarding the placement of the component. 

        var canvas = new zebra.ui.zCanvas(300,200);
        canvas.setLayout(new zebra.layout.BorderLayout());

        var mbar = new zebra.ui.Menubar({
            &quot;Item 1&quot;: {
                &quot;Subitem 1.1&quot;:null,
                &quot;Subitem 1.2&quot;:null,
                &quot;Subitem 1.3&quot;:null
            },
            &quot;Item 2&quot;: {
                &quot;Subitem 2.1&quot;:null,
                &quot;Subitem 2.2&quot;:null,
                &quot;Subitem 2.3&quot;:null
            },
            &quot;Item 3&quot;: null
        });

        canvas.root.add(zebra.layout.BOTTOM, mbar);

 * @class Menunbar
 * @constructor
 * @extends {zebra.ui.Panel}
 */
pkg.Menubar = Class(pkg.Panel, pkg.ChildrenListener, pkg.KeyListener, [
    function $prototype() {
        this.childInputEvent = function(e){
            var target = L.getDirectChild(this, e.source);
            switch(e.ID)
            {
                case MouseEvent.ENTERED:
                    if (this.over != target){
                        var prev = this.over;
                        this.over = target;
                        if(this.selected != null) this.$select(this.over);
                        else this.repaint2(prev, this.over);
                    }
                    break;
                case MouseEvent.EXITED:
                    var p = L.getRelLocation(e.absX, e.absY, pkg.findCanvas(this), this.over);
                    if (p[0] &lt; 0 || p[1] &lt; 0 || p[0] &gt;= this.over.width || p[1] &gt;= this.over.height){
                        var prev = this.over;
                        this.over = null;
                        if (this.selected == null) this.repaint2(prev, this.over);
                    }
                    break;
                case MouseEvent.CLICKED:
                    this.over = target;
                    this.$select(this.selected == target ? null : target);
                    break;
            }
        };

        this.activated = function(b) {
            if (b === false) this.$select(null);
        };

        this.$select = function(b){
            if(this.selected != b){
                var prev = this.selected, d = pkg.findCanvas(this);
                this.selected = b;
                if (d != null) {
                    var pop = d.getLayer(pkg.PopupLayer.ID);
                    pop.removeAll();
                    if(this.selected != null) {
                        pop.setMenubar(this);
                        var menu = this.getMenu(this.selected);
                        if (menu != null &amp;&amp; menu.hasVisibleItems()) {
                            var abs = L.getAbsLocation(0,0,this.selected);
                            menu.setLocation(abs[0], abs[1] + this.selected.height + 1);
                            pop.add(menu);
                        }
                    }
                    else pop.setMenubar(null);
                }
                this.repaint2(prev, this.selected);
            }
        };

        this.repaint2 = function(i1,i2){
            if (i1 != null) i1.repaint();
            if (i2 != null) i2.repaint();
        };

        this.paint = function(g){
            if (this.views) {
                var target = (this.selected != null) ? this.selected : this.over;
                if (target != null) {
                    var v = (this.selected != null) ? this.views[&quot;on&quot;] : this.views[&quot;off&quot;];
                    if (v != null) {
                        v.paint(g, target.x, target.y, target.width, target.height, this);
                    }
                }
            }
        };

        this.keyPressed = function(e){
            if (this.selected != null) {
                var idx = this.indexOf(this.selected), pidx = idx, c = null;
                if(e.code == KE.LEFT){
                    var ccc = this.kids.length;
                    do {
                        idx = (ccc + idx - 1) % ccc;
                        c = this.kids[idx];
                    }
                    while (c.isEnabled === false || c.isVisible === false);
                }
                else {
                    if(e.code == KE.RIGHT){
                        var ccc = this.kids.length;
                        do {
                            idx = (idx + 1) % ccc;
                            c = this.kids[idx];
                        }
                        while (c.isEnabled === false || c.isVisible === false);
                    }
                }
                if (idx != pidx) this.$select(this.kids[idx]);
            }
        };

        /**
         * Add a new item to the menu bar component and binds the given menu 
         * to it.
         * @param {zebra.ui.Panel|String} c an item title that can be passed as 
         * an UI component or a string.
         * @param {zebra.ui.Menu} m a menu
         * @method addMenu
         */
        this.addMenu = function(c, m){
            this.add(c);
            this.setMenuAt(this.kids.length - 1, m);
        };

        /**
         * Bind the specified menu to the given item of the menu bar
         * @param {Integer} i an index of a menu bar item
         * @param {zebra.ui.Menu} m a menu. Pass null as the parameter value
         * to unbind the given a menu from the given menu bar item
         * @method setMenuAt
         */
        this.setMenuAt = function(i, m){
            if (i &gt;= this.kids.length) throw new Error(&quot;Invalid kid index:&quot; + i);
            var c = this.kids[i];

            if(m == null) {
                var pm = this.menus.hasOwnProperty(c) ? this.menus[c] : null;
                if (pm != null) delete this.menus[c];
            }
            else {
                this.menus[c] = m;
            }
        };

        /**
         * Get a menu component that is bound to the given menu bar item
         * @param {Integer} i an index of a menu bar item
         * @return {zebra.ui.Menu}  an UI menu component
         * @method getMenuAt 
         */
        this.getMenuAt = function(i) {
            return this.getMenu(this.kids[i]);
        };

        /**
         * Get a menu component that is bound to the given menu bar item
         * @param {zebra.ui.Panel} c a menu bar item UI component 
         * @return {zebra.ui.Menu}  an UI menu component
         * @method getMenu
         */
        this.getMenu = function(c) {
            return this.menus.hasOwnProperty(c) ? this.menus[c] : null;
        };
    },

    function $clazz() {
        this.Label = Class(pkg.Label, []);
    },

    function (){
        this.menus = {};
        this.over = this.selected = null;
        this.$super();
    },

    function (d){
        this.$this();
        for(var k in d) {
            if (d.hasOwnProperty(k)) {
                if (d[k]) this.addMenu(k, new pkg.Menu(d[k]));
                else this.add(k);
            }
        }
    },

    function insert(i, constr, c) {
        if (zebra.isString(c)) c = new pkg.Menubar.Label(c);
        this.$super(i, constr, c);
    },

    function kidRemoved(i, c){
        this.setMenuAt(i, null);
        this.$super(i);
    },

    function removeAll(){
        this.$super();
        this.menus = {};
    }
]);
pkg.Menubar.prototype.setViews = pkg.$ViewsSetter;

/**
 * UI popup layer class. Special layer implementation to show 
 * context menu. Normally the layer is not used directly.   
 * @class PopupLayer
 * @constructor
 * @extends {zebra.ui.BaseLayer}
 */
pkg.PopupLayer = Class(pkg.BaseLayer, pkg.ChildrenListener, [
    function $clazz() {
        this.ID = &quot;pop&quot;;
    },

    function $prototype() {
        this.mTop = this.mLeft = this.mBottom = this.mRight = 0;

        this.layerMousePressed = function(x,y,mask){
            if(this.isLayerActive(x, y) &amp;&amp; this.getComponentAt(x, y) == this){
                this.removeAll();
                this.setMenubar(null);
            }
        };

        this.isLayerActive = function(x,y) {
            return this.kids.length &gt; 0 &amp;&amp;
                   (   arguments.length === 0 ||
                       this.mbar == null      ||
                       y &gt; this.mBottom       ||
                       y &lt; this.mTop          ||
                       x &lt; this.mLeft         ||
                       x &gt; this.mRight        ||
                       this.getComponentAt(x, y) != this );
        };

        this.childInputEvent = function(e){
            if(e.UID == pkg.InputEvent.KEY_UID){
                if (e.ID == KE.PRESSED &amp;&amp; e.code == KE.ESCAPE){
                    this.remove(L.getDirectChild(this, e.source));
                    if(this.kids === 0) this.setMenubar(null);
                }

                if (zebra.instanceOf(this.mbar, pkg.KeyListener)) {
                    pkg.events.performInput(new KE(this.mbar, e.ID, e.code, e.ch, e.mask));
                }
            }
        };

        this.calcPreferredSize = function (target){ return { width:0, height:0 }; };

        this.setMenubar = function(mb){
            if(this.mbar != mb){
                this.removeAll();
                if (this.mbar &amp;&amp; this.mbar.activated) this.mbar.activated(false);
                this.mbar = mb;
                if(this.mbar != null){
                    var abs = L.getAbsLocation(0, 0, this.mbar);
                    this.mLeft = abs[0];
                    this.mRight = this.mLeft + this.mbar.width - 1;
                    this.mTop = abs[1];
                    this.mBottom = this.mTop + this.mbar.height - 1;
                }
                if (this.mbar &amp;&amp; this.mbar.activated) this.mbar.activated(true);
            }
        };

        this.posChanged = function (target, prevOffset, prevLine, prevCol){
            if (timer.get(this)) timer.stop(this);

            var selectedIndex = target.offset;
            if (selectedIndex &gt;= 0){
                var index = this.pcMap.indexOf(target), sub = this.kids[index].getSubmenuAt(selectedIndex);

                if (index + 1 &lt; this.kids.length &amp;&amp; sub != this.kids[index + 1]) {
                    this.removeAt(index + 1);
                }

                if (index + 1 == this.kids.length &amp;&amp; sub != null) {
                    timer.start(this, 900, 5000);
                }
            }
        };

        this.fired  = function(src,data){
            var index = (data != null) ? src.selectedIndex :  -1;
            if (index &gt;= 0){
                var sub = src.getSubmenuAt(index);
                if(sub != null){
                    if (sub.parent == null){
                        sub.setLocation(src.x + src.width - 10, src.y + src.kids[index].y);
                        this.add(sub);
                    }
                    else {
                        pkg.focusManager.requestFocus(this.kids[this.kids.length - 1]);
                    }
                }
                else {
                    this.removeAll();
                    this.setMenubar(null);
                }
            }
            else {
                if (src.selectedIndex &gt;= 0) {
                    var sub = src.getSubmenuAt(src.selectedIndex);
                    if (sub != null) { this.remove(sub); }
                }
            }
        };

        this.run = function(){
            timer.stop(this);
            if (this.kids.length &gt; 0){
                var menu = this.kids[this.kids.length - 1];
                menu.select(menu.position.offset);
            }
        };

        this.doLayout = function (target){
            var cnt = this.kids.length;
            for(var i = 0; i &lt; cnt; i++){
                var m = this.kids[i];
                if(zebra.instanceOf(m, pkg.Menu)){
                    var ps = m.getPreferredSize(),
                        xx = (m.x + ps.width &gt; this.width) ? this.width - ps.width : m.x,
                        yy = (m.y + ps.height &gt; this.height) ? this.height - ps.height : m.y;
                    m.setSize(ps.width, ps.height);
                    if (xx &lt; 0) xx = 0;
                    if (yy &lt; 0) yy = 0;
                    m.setLocation(xx, yy);
                }
            }
        };
    },

    function (){
        this.mbar  = null;
        this.pcMap = [];
        this.$super(pkg.PopupLayer.ID);
    },

    function removeAt(index){
        for(var i = this.kids.length - 1;i &gt;= index; i--) this.$super(index);
    },

    function kidAdded(index,id,lw){
        this.$super(index, id, lw);
        if(zebra.instanceOf(lw, pkg.Menu)){
            lw.position.clearPos();
            lw.select(-1);
            this.pcMap.splice(index, 0, lw.position);
            lw._.add(this);
            lw.position._.add(this);
            lw.requestFocus();
        }
    },

    function kidRemoved(index,lw){
        this.$super(index, lw);
        if(zebra.instanceOf(lw, pkg.Menu)){
            lw._.remove(this);
            lw.position._.remove(this);
            this.pcMap.splice(index, 1);
            if(this.kids.length &gt; 0) {
                this.kids[this.kids.length - 1].select(-1);
                this.kids[this.kids.length - 1].requestFocus();
            }
        }
    }
]);

/**
 * Popup menu manager class. The manager registering and triggers showing context popup menu. 
 * Menu appearing is triggered by right mouse click or double fingers touch event.
 
        // create canvas
        var canvas = new zebra.ui.zCanvas();

        // create menu with three items
        var m = new zebra.ui.Menu();
        m.add(&quot;Menu Item 1&quot;);
        m.add(&quot;Menu Item 2&quot;);
        m.add(&quot;Menu Item 3&quot;);
    
        // bind the menu to root panel
        zebra.ui.popup.setPopup(canvas.root, m);
 
 * The popup manager use &quot;zebra.ui.PopupInfo&quot; interface implementation to understand which
 * popup menu has to be shown at the given location of the target UI component. Developer 
 * can tune a context menu appearing depending on the current mouse cursor or touch location:

        // create canvas
        var canvas = new zebra.ui.zCanvas();

        // visualize 50x50 pixels hot spot of toot component  
        // to which the context menu is bound 
        canvas.root.paint = function(g) {
            g.setColor(&quot;red&quot;);
            g.fillRect(50,50,50,50);
        }

        // create menu with three items
        var m = new zebra.ui.Menu();
        m.add(&quot;Menu Item 1&quot;);
        m.add(&quot;Menu Item 2&quot;);
        m.add(&quot;Menu Item 3&quot;);
    
        // bind the popup info interface implementation to the canvas
        // root component
        zebra.ui.popup.setPopup(canvas.root, new zebra.ui.PopupInfo([
            function getPopup(target, x, y) {
                // test if mouse cursor position is in red spot area
                // and return context menu if it is true 
                if (x &gt; 50 &amp;&amp; y &gt; 50 &amp;&amp; x &lt; 100 &amp;&amp; y &lt;  100)  {
                    return m;
                }
                return null;
            }
        ]));
 *
 *  Also developers can define a context menu on the level of component, 
 *  without necessary to register it in popup manager. For this just implement
 *  &quot;zebra.ui.PopupInfo&quot; interface with a component that has a context menu:
 
        // create canvas and set border layout for root panel
        var canvas = new zebra.ui.zCanvas();
        canvas.root.setLayout(new zebra.layout.BorderLayout());

        // instantiate anonymous label class that implements 
        // popup info interface to bind a context menu to 
        // the label
        var lab = new zebra.ui.Label(&quot;I have a context menu defined&quot;, 
                                     zebra.ui.PopupInfo, [
            function getPopup(target, x, y) { return m; }
        ]);
        lab.setBorder(&quot;plain&quot;);
        lab.setPadding(8);

        // create menu with three items
        var m = new zebra.ui.Menu();
        m.add(&quot;Menu Item 1&quot;);
        m.add(&quot;Menu Item 2&quot;);
        m.add(&quot;Menu Item 3&quot;);

        // add label to top part of root panel
        canvas.root.add(zebra.layout.TOP, lab);

 * @class PopupManager
 * @constructor
 * @extends {zebra.ui.Manager}
 */
pkg.PopupManager = Class(pkg.Manager, pkg.MouseListener, [
    function $prototype() {
        /**
         * Get popup info interface that is bound to the given component
         * @param  {zebra.ui.Panel} c an UI component
         * @return {zebra.ui.PopupInfo}  an popup info interface implementation
         * @method  getPopup
         */
        this.getPopup = function (c){
            return this.menus.hasOwnProperty(c) ? this.menus[c] : null;
        };

        this.mouseClicked = function (e){
            this.initialX = e.absX;
            this.initialY = e.absY;
            if((e.mask &amp; MouseEvent.RIGHT_BUTTON) &gt; 0) {
                this.showPopup(e.source, e.x, e.y); 
            }
        };

        this.fetchMenu = function(target,x,y){
            var popup = this.getPopup(target);
            return (popup != null) ? popup.getPopup(target, x, y) 
                                   : (zebra.instanceOf(target, pkg.PopupInfo) ? target.getPopup(target, x, y) 
                                                                              : null);
        };

        this.showPopup = function(target,x,y){
            var menu = this.fetchMenu(target, x, y);
            if (menu != null) {
                menu.setLocation(this.initialX, this.initialY);
                pkg.findCanvas(target).getLayer(pkg.PopupLayer.ID).add(menu);
                menu.requestFocus();
            }
            this.time = -1;
        };

        /**
         * Set the given context menu or an zebra.ui.PopupInfo interface implementation 
         * to the specified UI component.
         * @param {zebra.ui.Panel} c an UI component
         * @param {zebra.ui.Menu|zebra.ui.PopupInfo} p a popup info interface implementation
         * that says when and which context menu has to be shown for the given UI component.
         * Or UI context menu directly. Passing null as the argument value delete a context
         * menu definition from the given UI component. 
         * @method setPopup   
         */
        this.setPopup = function (c,p){
            if (p == null) { 
                delete this.menus[c];
            }
            else {
                if (zebra.instanceOf(p, pkg.PopupInfo) === false) {
                    var menu = p;
                    p = new pkg.PopupInfo([
                        function $prototype() {
                            this.getPopup = function(target, x, y) { return menu; };
                        }
                    ]); 
                } 
                this.menus[c] = p;
            }
        };
    },

    function () {
        this.$super();
        this.menus = {};
        this.time = this.initialX = this.initialY = 0;
    }
]);

pkg.WindowTitleView = Class(pkg.View, [
    function $prototype() {
        this[&#x27;&#x27;] = function(bg) {
            this.radius = 6;
            this.gap = this.radius;
            this.bg = bg ? bg : &quot;#66CCFF&quot;;
        };

        this.paint = function(g,x,y,w,h,d) {
            this.outline(g,x,y,w,h,d);
            g.setColor(this.bg);
            g.fill();
        };

        this.outline = function (g,x,y,w,h,d) {
            g.beginPath();
            g.moveTo(x + this.radius, y);
            g.lineTo(x + w - this.radius*2, y);
            g.quadraticCurveTo(x + w, y, x + w, y + this.radius);
            g.lineTo(x + w, y + h);
            g.lineTo(x, y + h);
            g.lineTo(x, y + this.radius);
            g.quadraticCurveTo(x, y, x + this.radius, y);
            return true;
        };
    }
]);  

})(zebra(&quot;ui&quot;), zebra.Class, zebra.Interface);
</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/js/tabs.js"></script>
</body>
</html>
