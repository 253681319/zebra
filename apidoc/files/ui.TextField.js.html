<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>ui.TextField.js - Zebra API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.8.0pr2/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="http://yui.yahooapis.com/combo?3.8.0pr2/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1>Zebra API: ui.TextField.js</a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 07/2013</em>
        </div>
    </div>
    <div class="yui3-g">

        <div id="sidebar" class="yui3-u">
            <div id="modules" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Packages</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="../modules/data.html">data</a>
                
                </li>
            
                <li><a href="../modules/io.html">io</a>
                
                </li>
            
                <li><a href="../modules/layout.html">layout</a>
                
                </li>
            
                <li><a href="../modules/ui.html">ui</a>
                
                </li>
            
                <li><a href="../modules/ui.designer.html">ui.designer</a>
                
                </li>
            
                <li><a href="../modules/ui.grid.html">ui.grid</a>
                
                </li>
            
                <li><a href="../modules/ui.tree.html">ui.tree</a>
                
                </li>
            
                <li><a href="../modules/util.html">util</a>
                
                </li>
            
                <li><a href="../modules/zebra.html">zebra</a>
                
                </li>
            
        </ul>
    </div>
</div>

<div id="classes" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Classes and interfaces</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="../classes/zebra.Class().html">zebra.Class()</a></li>
            
                <li><a href="../classes/zebra.data.Item.html">zebra.data.Item</a></li>
            
                <li><a href="../classes/zebra.data.ListModel.html">zebra.data.ListModel</a></li>
            
                <li><a href="../classes/zebra.data.Matrix.html">zebra.data.Matrix</a></li>
            
                <li><a href="../classes/zebra.data.SingleLineTxt.html">zebra.data.SingleLineTxt</a></li>
            
                <li><a href="../classes/zebra.data.Text.html">zebra.data.Text</a></li>
            
                <li><a href="../classes/zebra.data.TextModel.html">zebra.data.TextModel</a></li>
            
                <li><a href="../classes/zebra.data.TreeModel.html">zebra.data.TreeModel</a></li>
            
                <li><a href="../classes/zebra.Dummy.html">zebra.Dummy</a></li>
            
                <li><a href="../classes/zebra.forName().html">zebra.forName()</a></li>
            
                <li><a href="../classes/zebra.instanceOf().html">zebra.instanceOf()</a></li>
            
                <li><a href="../classes/zebra.Interface().html">zebra.Interface()</a></li>
            
                <li><a href="../classes/zebra.io.b64decode().html">zebra.io.b64decode()</a></li>
            
                <li><a href="../classes/zebra.io.b64encode().html">zebra.io.b64encode()</a></li>
            
                <li><a href="../classes/zebra.io.GET().html">zebra.io.GET()</a></li>
            
                <li><a href="../classes/zebra.io.HTTP.html">zebra.io.HTTP</a></li>
            
                <li><a href="../classes/zebra.io.ID().html">zebra.io.ID()</a></li>
            
                <li><a href="../classes/zebra.io.JRPC.html">zebra.io.JRPC</a></li>
            
                <li><a href="../classes/zebra.io.JRPC.invoke().html">zebra.io.JRPC.invoke()</a></li>
            
                <li><a href="../classes/zebra.io.POST().html">zebra.io.POST()</a></li>
            
                <li><a href="../classes/zebra.io.QS.html">zebra.io.QS</a></li>
            
                <li><a href="../classes/zebra.io.Service.html">zebra.io.Service</a></li>
            
                <li><a href="../classes/zebra.io.XRPC.html">zebra.io.XRPC</a></li>
            
                <li><a href="../classes/zebra.io.XRPC.invoke().html">zebra.io.XRPC.invoke()</a></li>
            
                <li><a href="../classes/zebra.layout.BorderLayout.html">zebra.layout.BorderLayout</a></li>
            
                <li><a href="../classes/zebra.layout.Constraints.html">zebra.layout.Constraints</a></li>
            
                <li><a href="../classes/zebra.layout.FlowLayout.html">zebra.layout.FlowLayout</a></li>
            
                <li><a href="../classes/zebra.layout.getAbsLocation().html">zebra.layout.getAbsLocation()</a></li>
            
                <li><a href="../classes/zebra.layout.getDirectAt().html">zebra.layout.getDirectAt()</a></li>
            
                <li><a href="../classes/zebra.layout.getDirectChild().html">zebra.layout.getDirectChild()</a></li>
            
                <li><a href="../classes/zebra.layout.getTopParent().html">zebra.layout.getTopParent()</a></li>
            
                <li><a href="../classes/zebra.layout.GridLayout.html">zebra.layout.GridLayout</a></li>
            
                <li><a href="../classes/zebra.layout.Layout.html">zebra.layout.Layout</a></li>
            
                <li><a href="../classes/zebra.layout.Layoutable.html">zebra.layout.Layoutable</a></li>
            
                <li><a href="../classes/zebra.layout.ListLayout.html">zebra.layout.ListLayout</a></li>
            
                <li><a href="../classes/zebra.layout.PercentLayout.html">zebra.layout.PercentLayout</a></li>
            
                <li><a href="../classes/zebra.layout.RasterLayout.html">zebra.layout.RasterLayout</a></li>
            
                <li><a href="../classes/zebra.layout.StackLayout.html">zebra.layout.StackLayout</a></li>
            
                <li><a href="../classes/zebra.ready().html">zebra.ready()</a></li>
            
                <li><a href="../classes/zebra.ui.BaseLayer.html">zebra.ui.BaseLayer</a></li>
            
                <li><a href="../classes/zebra.ui.BaseList.html">zebra.ui.BaseList</a></li>
            
                <li><a href="../classes/zebra.ui.BoldLabel.html">zebra.ui.BoldLabel</a></li>
            
                <li><a href="../classes/zebra.ui.Border.html">zebra.ui.Border</a></li>
            
                <li><a href="../classes/zebra.ui.BorderPan.html">zebra.ui.BorderPan</a></li>
            
                <li><a href="../classes/zebra.ui.Button.html">zebra.ui.Button</a></li>
            
                <li><a href="../classes/zebra.ui.Checkbox.html">zebra.ui.Checkbox</a></li>
            
                <li><a href="../classes/zebra.ui.Checkbox.Box.html">zebra.ui.Checkbox.Box</a></li>
            
                <li><a href="../classes/zebra.ui.ChildrenListener.html">zebra.ui.ChildrenListener</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.html">zebra.ui.Combo</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.ContentPan.html">zebra.ui.Combo.ContentPan</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.EditableContentPan.html">zebra.ui.Combo.EditableContentPan</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.ReadonlyContentPan.html">zebra.ui.Combo.ReadonlyContentPan</a></li>
            
                <li><a href="../classes/zebra.ui.ComboArrowView.html">zebra.ui.ComboArrowView</a></li>
            
                <li><a href="../classes/zebra.ui.CommandManager.html">zebra.ui.CommandManager</a></li>
            
                <li><a href="../classes/zebra.ui.CompList.html">zebra.ui.CompList</a></li>
            
                <li><a href="../classes/zebra.ui.ComponentListener.html">zebra.ui.ComponentListener</a></li>
            
                <li><a href="../classes/zebra.ui.Composite.html">zebra.ui.Composite</a></li>
            
                <li><a href="../classes/zebra.ui.CompositeView.html">zebra.ui.CompositeView</a></li>
            
                <li><a href="../classes/zebra.ui.CompRender.html">zebra.ui.CompRender</a></li>
            
                <li><a href="../classes/zebra.ui.CopyCutPaste.html">zebra.ui.CopyCutPaste</a></li>
            
                <li><a href="../classes/zebra.ui.Cursorable.html">zebra.ui.Cursorable</a></li>
            
                <li><a href="../classes/zebra.ui.CursorManager.html">zebra.ui.CursorManager</a></li>
            
                <li><a href="../classes/zebra.ui.designer.ShaperPan.html">zebra.ui.designer.ShaperPan</a></li>
            
                <li><a href="../classes/zebra.ui.Dotted.html">zebra.ui.Dotted</a></li>
            
                <li><a href="../classes/zebra.ui.Etched.html">zebra.ui.Etched</a></li>
            
                <li><a href="../classes/zebra.ui.EventManager.html">zebra.ui.EventManager</a></li>
            
                <li><a href="../classes/zebra.ui.findCanvas().html">zebra.ui.findCanvas()</a></li>
            
                <li><a href="../classes/zebra.ui.FocusListener.html">zebra.ui.FocusListener</a></li>
            
                <li><a href="../classes/zebra.ui.FocusManager.html">zebra.ui.FocusManager</a></li>
            
                <li><a href="../classes/zebra.ui.Font.html">zebra.ui.Font</a></li>
            
                <li><a href="../classes/zebra.ui.Gradient.html">zebra.ui.Gradient</a></li>
            
                <li><a href="../classes/zebra.ui.grid.DefEditors.html">zebra.ui.grid.DefEditors</a></li>
            
                <li><a href="../classes/zebra.ui.grid.Grid.html">zebra.ui.grid.Grid</a></li>
            
                <li><a href="../classes/zebra.ui.grid.GridCaption.html">zebra.ui.grid.GridCaption</a></li>
            
                <li><a href="../classes/zebra.ui.grid.GridStretchPan.html">zebra.ui.grid.GridStretchPan</a></li>
            
                <li><a href="../classes/zebra.ui.grid.Metrics.html">zebra.ui.grid.Metrics</a></li>
            
                <li><a href="../classes/zebra.ui.Group.html">zebra.ui.Group</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlElement.html">zebra.ui.HtmlElement</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlTextArea.html">zebra.ui.HtmlTextArea</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlTextField.html">zebra.ui.HtmlTextField</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlTextInput.html">zebra.ui.HtmlTextInput</a></li>
            
                <li><a href="../classes/zebra.ui.ImageLabel.html">zebra.ui.ImageLabel</a></li>
            
                <li><a href="../classes/zebra.ui.ImagePan.html">zebra.ui.ImagePan</a></li>
            
                <li><a href="../classes/zebra.ui.InputEvent.html">zebra.ui.InputEvent</a></li>
            
                <li><a href="../classes/zebra.ui.KeyEvent.html">zebra.ui.KeyEvent</a></li>
            
                <li><a href="../classes/zebra.ui.KeyListener.html">zebra.ui.KeyListener</a></li>
            
                <li><a href="../classes/zebra.ui.Label.html">zebra.ui.Label</a></li>
            
                <li><a href="../classes/zebra.ui.List.html">zebra.ui.List</a></li>
            
                <li><a href="../classes/zebra.ui.List.ViewProvider.html">zebra.ui.List.ViewProvider</a></li>
            
                <li><a href="../classes/zebra.ui.loadImage().html">zebra.ui.loadImage()</a></li>
            
                <li><a href="../classes/zebra.ui.Manager.html">zebra.ui.Manager</a></li>
            
                <li><a href="../classes/zebra.ui.Menu.html">zebra.ui.Menu</a></li>
            
                <li><a href="../classes/zebra.ui.Menunbar.html">zebra.ui.Menunbar</a></li>
            
                <li><a href="../classes/zebra.ui.MLabel.html">zebra.ui.MLabel</a></li>
            
                <li><a href="../classes/zebra.ui.MouseEvent.html">zebra.ui.MouseEvent</a></li>
            
                <li><a href="../classes/zebra.ui.MouseListener.html">zebra.ui.MouseListener</a></li>
            
                <li><a href="../classes/zebra.ui.MouseWheelSupport.html">zebra.ui.MouseWheelSupport</a></li>
            
                <li><a href="../classes/zebra.ui.PaintManager.html">zebra.ui.PaintManager</a></li>
            
                <li><a href="../classes/zebra.ui.PaintManImpl.html">zebra.ui.PaintManImpl</a></li>
            
                <li><a href="../classes/zebra.ui.Panel.html">zebra.ui.Panel</a></li>
            
                <li><a href="../classes/zebra.ui.PasswordText.html">zebra.ui.PasswordText</a></li>
            
                <li><a href="../classes/zebra.ui.Pattern.html">zebra.ui.Pattern</a></li>
            
                <li><a href="../classes/zebra.ui.Picture.html">zebra.ui.Picture</a></li>
            
                <li><a href="../classes/zebra.ui.PopupInfo.html">zebra.ui.PopupInfo</a></li>
            
                <li><a href="../classes/zebra.ui.PopupLayer.html">zebra.ui.PopupLayer</a></li>
            
                <li><a href="../classes/zebra.ui.PopupManager.html">zebra.ui.PopupManager</a></li>
            
                <li><a href="../classes/zebra.ui.Progress.html">zebra.ui.Progress</a></li>
            
                <li><a href="../classes/zebra.ui.Radial.html">zebra.ui.Radial</a></li>
            
                <li><a href="../classes/zebra.ui.Radiobox.html">zebra.ui.Radiobox</a></li>
            
                <li><a href="../classes/zebra.ui.RadioView.html">zebra.ui.RadioView</a></li>
            
                <li><a href="../classes/zebra.ui.Raised.html">zebra.ui.Raised</a></li>
            
                <li><a href="../classes/zebra.ui.Render.html">zebra.ui.Render</a></li>
            
                <li><a href="../classes/zebra.ui.RootLayer.html">zebra.ui.RootLayer</a></li>
            
                <li><a href="../classes/zebra.ui.RoundBorder.html">zebra.ui.RoundBorder</a></li>
            
                <li><a href="../classes/zebra.ui.Scroll.html">zebra.ui.Scroll</a></li>
            
                <li><a href="../classes/zebra.ui.ScrollManager.html">zebra.ui.ScrollManager</a></li>
            
                <li><a href="../classes/zebra.ui.ScrollPan.html">zebra.ui.ScrollPan</a></li>
            
                <li><a href="../classes/zebra.ui.Slider.html">zebra.ui.Slider</a></li>
            
                <li><a href="../classes/zebra.ui.SplitPan.html">zebra.ui.SplitPan</a></li>
            
                <li><a href="../classes/zebra.ui.StatePan.html">zebra.ui.StatePan</a></li>
            
                <li><a href="../classes/zebra.ui.Sunken.html">zebra.ui.Sunken</a></li>
            
                <li><a href="../classes/zebra.ui.SwitchManager.html">zebra.ui.SwitchManager</a></li>
            
                <li><a href="../classes/zebra.ui.Tabs.html">zebra.ui.Tabs</a></li>
            
                <li><a href="../classes/zebra.ui.TextArea.html">zebra.ui.TextArea</a></li>
            
                <li><a href="../classes/zebra.ui.TextField.html">zebra.ui.TextField</a></li>
            
                <li><a href="../classes/zebra.ui.TextRender.html">zebra.ui.TextRender</a></li>
            
                <li><a href="../classes/zebra.ui.Toolbar.html">zebra.ui.Toolbar</a></li>
            
                <li><a href="../classes/zebra.ui.TooltipInfo.html">zebra.ui.TooltipInfo</a></li>
            
                <li><a href="../classes/zebra.ui.TooltipManager.html">zebra.ui.TooltipManager</a></li>
            
                <li><a href="../classes/zebra.ui.tree.DefEditors.html">zebra.ui.tree.DefEditors</a></li>
            
                <li><a href="../classes/zebra.ui.tree.DefViews.html">zebra.ui.tree.DefViews</a></li>
            
                <li><a href="../classes/zebra.ui.tree.Tree.html">zebra.ui.tree.Tree</a></li>
            
                <li><a href="../classes/zebra.ui.View.html">zebra.ui.View</a></li>
            
                <li><a href="../classes/zebra.ui.ViewPan.html">zebra.ui.ViewPan</a></li>
            
                <li><a href="../classes/zebra.ui.ViewSet.html">zebra.ui.ViewSet</a></li>
            
                <li><a href="../classes/zebra.ui.Window.html">zebra.ui.Window</a></li>
            
                <li><a href="../classes/zebra.ui.WinLayer.html">zebra.ui.WinLayer</a></li>
            
                <li><a href="../classes/zebra.ui.WinListener.html">zebra.ui.WinListener</a></li>
            
                <li><a href="../classes/zebra.ui.zCanvas.html">zebra.ui.zCanvas</a></li>
            
                <li><a href="../classes/zebra.URL.html">zebra.URL</a></li>
            
                <li><a href="../classes/zebra.util.Bag.html">zebra.util.Bag</a></li>
            
                <li><a href="../classes/zebra.util.findInTree().html">zebra.util.findInTree()</a></li>
            
                <li><a href="../classes/zebra.util.Listeners.html">zebra.util.Listeners</a></li>
            
                <li><a href="../classes/zebra.util.newInstance().html">zebra.util.newInstance()</a></li>
            
                <li><a href="../classes/zebra.util.Position.html">zebra.util.Position</a></li>
            
                <li><a href="../classes/zebra.util.Position.Metric.html">zebra.util.Position.Metric</a></li>
            
                <li><a href="../classes/zebra.util.rgb.html">zebra.util.rgb</a></li>
            
        </ul>
    </div>
</div>












        </div>

        <div id="main" class="yui3-u">
            <div class="content"><h4>ui.TextField.js</h4>

<pre class="code prettyprint linenums">
(function(pkg, Class) {


/**
 * @module ui
 * @namespace zebra.ui
 */

var ME = pkg.MouseEvent, KE = pkg.KeyEvent, PO = zebra.util.Position;

/**
 * Text field UI component. The component is designed to enter single line, multi lines or password text.
 * The component implement text field functionality from the scratch. It supports the following features
 
    - Text selection
    - Redu/Undo actions
    - Native WEB clipboard 
    - Basic text navigation
    - Read-only mode

 * @constructor
 * @param {String|zebra.data.TextModel|zebra.ui.TextRender} [txt] a text the text field component 
 * has to be filled. The parameter can be a simple string, text model or text render class instance.
 * @param {Integer} [maxCol] a maximal size of entered text. -1 means the size of the edited text
 * has no length limit.  
 * @class TextField
 * @extends zebra.ui.Label
 */
pkg.TextField = Class(pkg.Label, pkg.KeyListener, pkg.MouseListener, 
                      pkg.FocusListener, pkg.Cursorable, pkg.CopyCutPaste, [

    function $clazz() {
        this.TextPosition = Class(PO, [
            function (render){
                  this.$super(render);
                  render.target._.add(this);
            },

            function $prototype() {
                this.textUpdated = function(src, b, off, size, startLine, lines){
                      if (b === true) this.inserted(off, size);
                      else this.removed(off, size);
                };
            },

            function destroy() { this.metrics.target._.remove(this); }
        ]);
    },

    function $prototype() {
        /**
         * Selection color
         * @attribute  selectionColor
         * @type {String}
         * @readOnlyn
         */
        this.selectionColor = this.curView = this.position = null;


        /**
         * Cursor view
         * @attribute curView
         * @type {zebra.ui.View}
         * @readOnlyn
         */
        
        /**
         * Indicate if the text field is editable
         * @attribute  isEditable
         * @type {Boolean}
         * @default true
         * @readOnly
         */
        this.isEditable = true;

        this.getTextRowColAt = function(render,x,y){
            var size = render.target.getLines();
            if (size === 0) return null;

            var lh = render.getLineHeight(), li = render.getLineIndent(),
                ln = (y &lt; 0) ? 0 : ~~((y + li) / (lh + li)) + ((y + li) % (lh + li) &gt; li ? 1 : 0) -1;

            if(ln &gt;= size) return [size - 1, render.getLine(size - 1).length];
            else if (ln &lt; 0) return [0,0];

            if(x &lt; 0) return [ln, 0];

            var x1 = 0, x2 = 0, s = render.getLine(ln);
            for(var c = 0; c &lt; s.length; c++){
                x1 = x2;
                x2 = render.font.charsWidth(s, 0, c + 1);
                if(x &gt;= x1 &amp;&amp; x &lt; x2) return [ln, c];
            }
            return [ln, s.length];
        };

        this.findNextWord = function(t,line,col,d){
            if(line &lt; 0 || line &gt;= t.getLines()) return null;
            var ln = t.getLine(line);
            col += d;
            if (col &lt; 0 &amp;&amp; line &gt; 0) return [line - 1, t.getLine(line - 1).length];
            else {
                if (col &gt; ln.length &amp;&amp; line &lt; t.getLines() - 1) return [line + 1, 0];
            }

            var b = false;
            for(; col &gt;= 0 &amp;&amp; col &lt; ln.length; col += d){
                if (b) {
                    if (d &gt; 0) { if(zebra.util.isLetter(ln[col])) return [line, col]; }
                    else {
                        if (!zebra.util.isLetter(ln[col])) return [line, col + 1];
                    }
                }
                else  {
                    b = d &gt; 0 ? !zebra.util.isLetter(ln[col]) : zebra.util.isLetter(ln[col]);
                }
            }
            return (d &gt; 0 ? [line, ln.length ]: [line, 0]);
        };

        this.getSubString = function(r,start,end){
            var res = [], sr = start[0], er = end[0], sc = start[1], ec = end[1];
            for(var i = sr; i &lt; er + 1; i++){
                var ln = r.getLine(i);
                if (i != sr) res.push(&#x27;\n&#x27;);
                else ln = ln.substring(sc);
                if(i == er) ln = ln.substring(0, ec - ((sr == er) ? sc : 0));
                res.push(ln);
            }
            return res.join(&#x27;&#x27;);
        };

        /**
         * Remove selected text
         * @method removeSelected
         */
        this.removeSelected = function(){
            if (this.hasSelection()){
                var start = Math.min(this.startOff, this.endOff);
                this.remove(start, Math.max(this.startOff, this.endOff) - start);
                this.clearSelection();
            }
        };

        this.startSelection = function(){
            if (this.startOff &lt; 0){
                var pos = this.position;
                this.endLine = this.startLine = pos.currentLine;
                this.endCol = this.startCol = pos.currentCol;
                this.endOff = this.startOff = pos.offset;
            }
        };

        this.keyTyped = function(e){
            if (e.isControlPressed() || e.isCmdPressed() || this.isEditable === false ||
                (e.ch == &#x27;\n&#x27; &amp;&amp; zebra.instanceOf(this.view.target, zebra.data.SingleLineTxt)))
            {
                return;
            }

            this.removeSelected();
            this.write(this.position.offset, e.ch);
        };

        this.selectAll_command = function() {
            this.select(0, this.position.metrics.getMaxOffset());
        };

        this.nextWord_command = function(b, d) {
            if (b) this.startSelection();
            var p = this.findNextWord(this.view.target, this.position.currentLine, 
                                                        this.position.currentCol, d);
            if(p != null) this.position.setRowCol(p[0], p[1]);
        };

        this.nextPage_command = function(b, d) {
            if (b) this.startSelection();
            this.position.seekLineTo(d == 1 ? PO.DOWN : PO.UP, this.pageSize());
        };

        this.keyPressed = function(e) {
            if (this.isFiltered(e)) return;

            var position    = this.position,
                col         = position.currentCol,
                isShiftDown = e.isShiftPressed(),
                line        = position.currentLine,
                foff        = 1;

            if (isShiftDown &amp;&amp; e.ch == KE.CHAR_UNDEFINED) {
                this.startSelection();
            }

            switch(e.code)
            {
                case KE.DOWN: position.seekLineTo(PO.DOWN);break;
                case KE.UP: position.seekLineTo(PO.UP);break;
                case KE.LEFT : foff = -1;
                case KE.RIGHT:
                    if (e.isControlPressed() === false &amp;&amp; e.isCmdPressed() === false) {
                        position.seek(foff);
                    }
                    break;
                case KE.END:
                    if (e.isControlPressed()) {
                        position.seekLineTo(PO.DOWN, position.metrics.getLines() - line - 1);
                    }
                    else position.seekLineTo(PO.END);
                    break;
                case KE.HOME:
                    if (e.isControlPressed()) position.seekLineTo(PO.UP, line);
                    else position.seekLineTo(PO.BEG);
                    break;
                case KE.DELETE:
                    if (this.hasSelection() &amp;&amp; this.isEditable) {
                        this.removeSelected();
                    }
                    else {
                        if (this.isEditable) this.remove(position.offset, 1);
                    } break;
                case KE.BSPACE:
                    if (this.isEditable) {
                        if (this.hasSelection()) this.removeSelected();
                        else {
                            if (this.isEditable &amp;&amp; position.offset &gt; 0){
                                position.seek(-1);
                                this.remove(position.offset, 1);
                            }
                        }
                    } break;
                default: return ;
            }

            if (isShiftDown === false &amp;&amp; this.isEditable) {
                this.clearSelection();
            }
        };

        /**
         * Test if the given key pressed event has to be processed
         * @protected
         * @param  {zebra.ui.KeyEvent} e a key event
         * @return {Boolean} true if the given key pressed event doesn&#x27;t 
         * have be processed
         * @method isFiltered  
         */
        this.isFiltered = function(e){
            var code = e.code;
            return code == KE.SHIFT || code == KE.CTRL || code == KE.TAB || code == KE.ALT || (e.mask &amp; KE.M_ALT) &gt; 0;
        };

        /**
         * Remove the specified part of edited text 
         * @param  {Integer} pos  a start position of a removed text
         * @param  {Integer} size a size of removed text
         * @method remove
         */
        this.remove = function (pos,size){
            var position = this.position;
            if (pos &gt;= 0 &amp;&amp; (pos + size) &lt;= position.metrics.getMaxOffset()) {
                if (this.isEditable &amp;&amp; size &lt; 10000) {
                    this.historyPos = (this.historyPos + 1) % this.history.length;
                    this.history[this.historyPos] = [-1, pos, this.getValue().substring(pos, pos+size)];
                    if (this.undoCounter &lt; this.history.length) this.undoCounter++;
                }

                var pl = position.metrics.getLines(), old = position.offset;
                this.view.target.remove(pos, size);
                if (position.metrics.getLines() != pl || old == pos) this.repaint();
            }
        };

        /**
         * Insert the specified text into the edited text at the given position
         * @param  {Integer} pos  a start position of a removed text
         * @param  {String} s a text to be inserted
         * @method write
         */
        this.write = function (pos,s){
            if (this.isEditable &amp;&amp; s.length &lt; 10000) {
                this.historyPos = (this.historyPos + 1) % this.history.length;
                this.history[this.historyPos] = [1, pos, s.length];
                if (this.undoCounter &lt; this.history.length) this.undoCounter++;
            }

            var old = this.position.offset, m = this.view.target, pl = m.getLines();
            m.write(s, pos);
            if (m.getLines() != pl || this.position.offset == old) this.repaint();
        };

        this.recalc = function() {
            var r = this.view, p = this.position;
            if(p.offset &gt;= 0){
                var cl = p.currentLine;
                this.curX = r.font.charsWidth(r.getLine(cl), 0, p.currentCol) + this.getLeft();
                this.curY = cl * (r.getLineHeight() + r.getLineIndent()) + this.getTop();
            }
            this.curH = r.getLineHeight() - 1;
        };

        this.getCursorType = function(target,x,y){ return pkg.Cursor.TEXT; };
        this.catchScrolled = function (psx,psy){ this.repaint(); };
        this.canHaveFocus = function (){ return true;};

        /**
         * Draw the text field cursor
         * @protected
         * @param  {2DContext} g  a 2D contextnn
         * @method drawCursor
         */
        this.drawCursor = function (g){
            if (this.isEditable &amp;&amp; this.hasFocus() &amp;&amp; this.position.offset &gt;= 0 &amp;&amp; this.curView != null){
                this.curView.paint(g, this.curX, this.curY, this.curW, this.curH, this);
            }
        };

        this.mouseDragStarted = function (e){
            if (e.mask == ME.LEFT_BUTTON &amp;&amp; this.position.metrics.getMaxOffset() &gt; 0) {
                this.startSelection();
            }
        };

        this.mouseDragEnded =function (e){
            if (e.mask == ME.LEFT_BUTTON &amp;&amp; this.hasSelection() === false) this.clearSelection();
        };

        this.mouseDragged = function (e){
            if (e.mask == ME.LEFT_BUTTON){
                var p = this.getTextRowColAt(this.view, e.x - this.scrollManager.getSX(), 
                                                        e.y - this.scrollManager.getSY());
                if (p != null) this.position.setRowCol(p[0], p[1]);
            }
        };

        /**
         * Select the specified part of the edited text
         * @param  {Integer} startOffset a start position of a selected text
         * @param  {Integer} endOffset  an end position of a selected text
         * @method select
         */
        this.select = function (startOffset,endOffset){
            if (endOffset &lt; startOffset || 
                startOffset &lt; 0 || 
                endOffset &gt; this.position.metrics.getMaxOffset())
            {
                throw new Error(&quot;Invalid selection offsets&quot;);
            }

            if (this.startOff != startOffset || endOffset != this.endOff){
                if(startOffset == endOffset) this.clearSelection();
                else {
                    this.startOff = startOffset;
                    var p = this.position.getPointByOffset(startOffset);
                    this.startLine = p[0];
                    this.startCol = p[1];
                    this.endOff = endOffset;
                    p = this.position.getPointByOffset(endOffset);
                    this.endLine = p[0];
                    this.endCol = p[1];
                    this.repaint();
                }
            }
        };

        /**
         * Test if the text field has a selected text
         * @return {Boolean} true if the text field has a selected text
         * @method hasSelection
         */
        this.hasSelection = function () { return this.startOff != this.endOff; };

        this.posChanged = function (target,po,pl,pc){
            this.recalc();
            var position = this.position;
            if(position.offset &gt;= 0){
                var lineHeight = this.view.getLineHeight(), top = this.getTop();
                this.scrollManager.makeVisible(this.curX, this.curY, this.curW, lineHeight);
                if(pl &gt;= 0){
                    if(this.startOff &gt;= 0){
                        this.endLine = position.currentLine;
                        this.endCol = position.currentCol;
                        this.endOff = position.offset;
                    }
                    var minUpdatedLine = Math.min(pl, position.currentLine), li = this.view.getLineIndent(),
                        bottom = this.getBottom(), left = this.getLeft(),
                        y1 = lineHeight * minUpdatedLine + minUpdatedLine * li + top + this.scrollManager.getSY();
                    if(y1 &lt; top) y1 = top;
                    if(y1 &lt; this.height - bottom){
                        var h = (Math.max(pl, position.currentLine) - minUpdatedLine + 1) * (lineHeight + li);
                        if( y1 + h &gt; this.height - bottom) h = this.height - bottom - y1;
                        this.repaint(left, y1, this.width - left - this.getRight(), h);
                    }
                }
                else this.repaint();
            }
        };

        this.paintOnTop = function(g) {
            if (this.hint &amp;&amp; this.hasFocus() === false &amp;&amp; this.getValue() == &#x27;&#x27;) {
                this.hint.paint(g, this.getLeft(), this.height - this.getBottom() - this.hint.getLineHeight(),
                                this.width, this.height, this);
            }
        };

        /**
         * Set the specified hint text to be drawn with the given font and color.
         * The hint is not-editable text that is shown in empty text field to help 
         * a user to understand which input the text field expects. 
         * @param {String} hint a hint text
         * @param {String|zebra.ui.Font} font a font 
         * @param {String} color a hint color
         * @method setHint
         */
        this.setHint = function(hint, font, color) {
            this.hint = hint;
            if (hint != null &amp;&amp; zebra.instanceOf(hint, pkg.View) === false) {
                this.hint = new pkg.TextRender(hint);
                font  = font  ? font  : pkg.TextField.hintFont;
                color = color ? color : pkg.TextField.hintColor;
                this.hint.setColor(color);
                this.hint.setFont(font);
            }
            this.repaint();
            return this.hint;
        };

        this.undo_command = function() {
            if (this.undoCounter &gt; 0) {
                var h = this.history[this.historyPos];

                this.historyPos--;
                if (h[0] == 1) this.remove(h[1], h[2]);
                else           this.write (h[1], h[2]);

                this.undoCounter -= 2;
                this.redoCounter++;

                this.historyPos--;
                if (this.historyPos &lt; 0) this.historyPos = this.history.length - 1;

                this.repaint();
            }
        };

        this.redo_command = function() {
            if (this.redoCounter &gt; 0) {
                var h = this.history[(this.historyPos + 1) % this.history.length];
                if (h[0] == 1) this.remove(h[1], h[2]);
                else           this.write (h[1], h[2]);
                this.redoCounter--;
                this.repaint();
            }
        };

        /**
         * Get a starting position (row and column) of a selected text
         * @return {Array} a position of a selected text. First element 
         * of is a row and second column of selected text. null if 
         * there is no any selected text
         * @method getStartSelection
         */
        this.getStartSelection = function(){
            return this.startOff != this.endOff ? ((this.startOff &lt; this.endOff) ? [this.startLine, this.startCol]
                                                                                 : [this.endLine, this.endCol]) : null;
        };

        /**
         * Get an ending position (row and column) of a selected text
         * @return {Array} a position of a selected text. First element 
         * of is a row and second column of selected text. null if 
         * there is no any selected text
         * @method getEndSelection
         */
        this.getEndSelection = function(){
            return this.startOff != this.endOff ? ((this.startOff &lt; this.endOff) ? [this.endLine, this.endCol]
                                                                                 : [this.startLine, this.startCol]) : null;
        };

        /**
         * Get a selected text
         * @return {String} a selected text
         * @method getSelectedText
         */
        this.getSelectedText = function(){
            return this.startOff != this.endOff ? this.getSubString(this.view, this.getStartSelection(), this.getEndSelection())
                                                : null;
        };

        this.focusGained = function (e){
            if (this.position.offset &lt; 0) this.position.setOffset(0);
            else {
                if (this.hint != null) this.repaint();
                else {
                    if (this.isEditable) {
                        this.repaint(this.curX + this.scrollManager.getSX(),
                                     this.curY + this.scrollManager.getSY(),
                                     this.curW, this.curH);
                    }
                }
            }
        };

        this.focusLost = function(e){
            if (this.isEditable) {
                if (this.hint) this.repaint();
                else {
                    this.repaint(this.curX + this.scrollManager.getSX(),
                                 this.curY + this.scrollManager.getSY(),
                                 this.curW, this.curH);
                }
            }
        };

        /**
         * Clear a text selection. 
         * @method clearSelection
         */
        this.clearSelection = function (){
            if (this.startOff &gt;= 0){
                var b = this.hasSelection();
                this.endOff = this.startOff =  -1;
                if (b) this.repaint();
            }
        };

        this.pageSize = function (){
            var height = this.height - this.getTop() - this.getBottom(),
                indent = this.view.getLineIndent(),
                textHeight = this.view.getLineHeight();
            return (((height + indent) / (textHeight + indent) + 0.5) | 0) +
                   (((height + indent) % (textHeight + indent) &gt; indent) ? 1 : 0);
        };

        this.createPosition = function (r){ return new pkg.TextField.TextPosition(r); };

        this.paste = function(txt){
            if (txt != null){
                this.removeSelected();
                this.write(this.position.offset, txt);
            }
        };

        this.copy = function() {
            return this.getSelectedText();
        };

        this.cut = function() {
            var t = this.getSelectedText();
            if (this.isEditable) this.removeSelected();
            return t;
        };

        /**
         * Set the specified cursor position controller 
         * @param {zebra.util.Position} p a position controller
         * @method setPosition
         */
        this.setPosition = function (p){
            if (this.position != p){
                if (this.position != null){
                    this.position._.remove(this);
                    if (this.position.destroy) this.position.destroy();
                }
                this.position = p;
                this.position._.add(this);
                this.invalidate();
            }
        };

        /**
         * Set the cursor view. The view defines rendering of the text field 
         * cursor.
         * @param {zebra.ui.View} v a cursor view
         * @method setCursorView
         */
        this.setCursorView = function (v){
            // !!!
            // cursor size should be set by property
            this.curW = 1;
            this.curView = pkg.$view(v);
            //this.curW = this.curView != null ? this.curView.getPreferredSize().width : 1;
            this.vrp();
        };

        /**
         * Adjust the size of the text field component to be enough to place the given
         * number of rows and columns.
         * @param {Integer} r a row of the text the height of the text field has to be adjusted
         * @param {Integer} c a column of the text the width of the text field has to be adjusted
         * @method setPSByRowsCols
         */
        this.setPSByRowsCols = function (r,c){
            var tr = this.view, w = (c &gt; 0) ? (tr.font.stringWidth(&quot;W&quot;) * c) : this.psWidth,
                h = (r &gt; 0) ? (r * tr.getLineHeight() + (r - 1) * tr.getLineIndent()) : this.psHeight;
            this.setPreferredSize(w, h);
        };

        /**
         * Control the text field editable state
         * @param {Boolean} b true to make the text field editable
         * @method setEditable
         */
        this.setEditable = function (b){
            if(b != this.isEditable){
                this.isEditable = b;
                this.vrp();
            }
        };

        this.mousePressed = function(e){
            if (e.isActionMask()){
                if (e.clicks &gt; 1) this.select(0, this.position.metrics.getMaxOffset());
                else {
                    if ((e.mask &amp; KE.M_SHIFT) &gt; 0) this.startSelection();
                    else this.clearSelection();
                    var p = this.getTextRowColAt(this.view, e.x - this.scrollManager.getSX() - this.getLeft(),
                                                            e.y - this.scrollManager.getSY() - this.getTop());
                    if (p != null) this.position.setRowCol(p[0], p[1]);
                }
            }
        };

        /**
         * Set selection color
         * @param {String} c a selection color
         * @method setSelectionColor
         */
        this.setSelectionColor = function (c){
            if (c != this.selectionColor){
                this.selectionColor = c;
                if (this.hasSelection()) this.repaint();
            }
        };

        this.calcPreferredSize = function (t) {
            return this.view.getPreferredSize();
        };

        //!!! to maixinmal optimize performance the method duplicates part of ViewPan.paint() code
        this.paint = function(g){
            var sx = this.scrollManager.getSX(), sy = this.scrollManager.getSY();
            try{
                g.translate(sx, sy);

                //!!! this code can be found in ViewPan.paint()
                var l = this.getLeft(), t = this.getTop();
                this.view.paint(g, l, t, this.width  - l - this.getRight(),
                                         this.height - t - this.getBottom(), this);
                this.drawCursor(g);
            }
            catch(e) { throw e; }
            finally { g.translate( -sx,  -sy); }
        };
    },

    function () { this.$this(&quot;&quot;); },

    function(s, maxCol){
        var b = zebra.isNumber(maxCol);
        this.$this(b ? new zebra.data.SingleLineTxt(s, maxCol) : (maxCol ? new zebra.data.Text(s) : s));
        if (b &amp;&amp; maxCol &gt; 0) this.setPSByRowsCols(-1, maxCol);
    },

    function (render){
        if (zebra.isString(render)) {
            render = new pkg.TextRender(new zebra.data.SingleLineTxt(render));
        }
        else {
            if (zebra.instanceOf(render, zebra.data.TextModel)) {
                render = new pkg.TextRender(render);
            }
        }
        this.startLine = this.startCol = this.endLine = this.endCol = this.curX = 0;
        this.startOff = this.endOff = -1;
        this.history = Array(100);
        this.historyPos = -1;
        this.redoCounter = this.undoCounter = this.curY = this.curW = this.curH = 0;

        this.$super(render);
        this.scrollManager = new pkg.ScrollManager(this);
    },

    function setView(v){
        if(v != this.view){
            this.$super(v);
            this.setPosition(this.createPosition(this.view));
        }
    },

    /**
     * Set the text content of the text field component
     * @param {String} s a text the text field component has to be filled
     * @method setValue
     */
    function setValue(s){
        var txt = this.getValue();
        if (txt != s){
            this.position.setOffset(0);
            this.scrollManager.scrollTo(0, 0);
            this.$super(s);
        }
    },

    function setEnabled(b){
        this.clearSelection();
        this.$super(b);
    }
]);

/**
 * Text area UI component. The UI component to render multi-lines text.
 * @class TextArea
 * @constructor
 * @param {String} [txt] a text 
 * @extends zebra.ui.TextField
 */
pkg.TextArea = Class(pkg.TextField, [
    function() {
        this.$this(&quot;&quot;);
    },

    function(txt) {
        this.$super(new zebra.data.Text(txt));
    }
]);


})(zebra(&quot;ui&quot;), zebra.Class);
</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/js/tabs.js"></script>
</body>
</html>
