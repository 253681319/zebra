<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>util.js - Zebra API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.8.0pr2/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="http://yui.yahooapis.com/combo?3.8.0pr2/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1>Zebra API: util.js</a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 07/2013</em>
        </div>
    </div>
    <div class="yui3-g">

        <div id="sidebar" class="yui3-u">
            <div id="modules" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Packages</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="../modules/data.html">data</a>
                
                </li>
            
                <li><a href="../modules/io.html">io</a>
                
                </li>
            
                <li><a href="../modules/layout.html">layout</a>
                
                </li>
            
                <li><a href="../modules/ui.html">ui</a>
                
                </li>
            
                <li><a href="../modules/ui.designer.html">ui.designer</a>
                
                </li>
            
                <li><a href="../modules/ui.grid.html">ui.grid</a>
                
                </li>
            
                <li><a href="../modules/ui.tree.html">ui.tree</a>
                
                </li>
            
                <li><a href="../modules/util.html">util</a>
                
                </li>
            
                <li><a href="../modules/zebra.html">zebra</a>
                
                </li>
            
        </ul>
    </div>
</div>

<div id="classes" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Classes and interfaces</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="../classes/zebra.Class().html">zebra.Class()</a></li>
            
                <li><a href="../classes/zebra.data.Item.html">zebra.data.Item</a></li>
            
                <li><a href="../classes/zebra.data.ListModel.html">zebra.data.ListModel</a></li>
            
                <li><a href="../classes/zebra.data.Matrix.html">zebra.data.Matrix</a></li>
            
                <li><a href="../classes/zebra.data.SingleLineTxt.html">zebra.data.SingleLineTxt</a></li>
            
                <li><a href="../classes/zebra.data.Text.html">zebra.data.Text</a></li>
            
                <li><a href="../classes/zebra.data.TextModel.html">zebra.data.TextModel</a></li>
            
                <li><a href="../classes/zebra.data.TreeModel.html">zebra.data.TreeModel</a></li>
            
                <li><a href="../classes/zebra.Dummy.html">zebra.Dummy</a></li>
            
                <li><a href="../classes/zebra.forName().html">zebra.forName()</a></li>
            
                <li><a href="../classes/zebra.instanceOf().html">zebra.instanceOf()</a></li>
            
                <li><a href="../classes/zebra.Interface().html">zebra.Interface()</a></li>
            
                <li><a href="../classes/zebra.io.b64decode().html">zebra.io.b64decode()</a></li>
            
                <li><a href="../classes/zebra.io.b64encode().html">zebra.io.b64encode()</a></li>
            
                <li><a href="../classes/zebra.io.GET().html">zebra.io.GET()</a></li>
            
                <li><a href="../classes/zebra.io.HTTP.html">zebra.io.HTTP</a></li>
            
                <li><a href="../classes/zebra.io.ID().html">zebra.io.ID()</a></li>
            
                <li><a href="../classes/zebra.io.JRPC.html">zebra.io.JRPC</a></li>
            
                <li><a href="../classes/zebra.io.JRPC.invoke().html">zebra.io.JRPC.invoke()</a></li>
            
                <li><a href="../classes/zebra.io.POST().html">zebra.io.POST()</a></li>
            
                <li><a href="../classes/zebra.io.QS.html">zebra.io.QS</a></li>
            
                <li><a href="../classes/zebra.io.Service.html">zebra.io.Service</a></li>
            
                <li><a href="../classes/zebra.io.XRPC.html">zebra.io.XRPC</a></li>
            
                <li><a href="../classes/zebra.io.XRPC.invoke().html">zebra.io.XRPC.invoke()</a></li>
            
                <li><a href="../classes/zebra.layout.BorderLayout.html">zebra.layout.BorderLayout</a></li>
            
                <li><a href="../classes/zebra.layout.Constraints.html">zebra.layout.Constraints</a></li>
            
                <li><a href="../classes/zebra.layout.FlowLayout.html">zebra.layout.FlowLayout</a></li>
            
                <li><a href="../classes/zebra.layout.getAbsLocation().html">zebra.layout.getAbsLocation()</a></li>
            
                <li><a href="../classes/zebra.layout.getDirectAt().html">zebra.layout.getDirectAt()</a></li>
            
                <li><a href="../classes/zebra.layout.getDirectChild().html">zebra.layout.getDirectChild()</a></li>
            
                <li><a href="../classes/zebra.layout.getTopParent().html">zebra.layout.getTopParent()</a></li>
            
                <li><a href="../classes/zebra.layout.GridLayout.html">zebra.layout.GridLayout</a></li>
            
                <li><a href="../classes/zebra.layout.Layout.html">zebra.layout.Layout</a></li>
            
                <li><a href="../classes/zebra.layout.Layoutable.html">zebra.layout.Layoutable</a></li>
            
                <li><a href="../classes/zebra.layout.ListLayout.html">zebra.layout.ListLayout</a></li>
            
                <li><a href="../classes/zebra.layout.PercentLayout.html">zebra.layout.PercentLayout</a></li>
            
                <li><a href="../classes/zebra.layout.RasterLayout.html">zebra.layout.RasterLayout</a></li>
            
                <li><a href="../classes/zebra.layout.StackLayout.html">zebra.layout.StackLayout</a></li>
            
                <li><a href="../classes/zebra.ready().html">zebra.ready()</a></li>
            
                <li><a href="../classes/zebra.ui.BaseLayer.html">zebra.ui.BaseLayer</a></li>
            
                <li><a href="../classes/zebra.ui.BaseList.html">zebra.ui.BaseList</a></li>
            
                <li><a href="../classes/zebra.ui.BoldLabel.html">zebra.ui.BoldLabel</a></li>
            
                <li><a href="../classes/zebra.ui.Border.html">zebra.ui.Border</a></li>
            
                <li><a href="../classes/zebra.ui.BorderPan.html">zebra.ui.BorderPan</a></li>
            
                <li><a href="../classes/zebra.ui.Button.html">zebra.ui.Button</a></li>
            
                <li><a href="../classes/zebra.ui.Checkbox.html">zebra.ui.Checkbox</a></li>
            
                <li><a href="../classes/zebra.ui.Checkbox.Box.html">zebra.ui.Checkbox.Box</a></li>
            
                <li><a href="../classes/zebra.ui.ChildrenListener.html">zebra.ui.ChildrenListener</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.html">zebra.ui.Combo</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.ContentPan.html">zebra.ui.Combo.ContentPan</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.EditableContentPan.html">zebra.ui.Combo.EditableContentPan</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.ReadonlyContentPan.html">zebra.ui.Combo.ReadonlyContentPan</a></li>
            
                <li><a href="../classes/zebra.ui.ComboArrowView.html">zebra.ui.ComboArrowView</a></li>
            
                <li><a href="../classes/zebra.ui.CommandManager.html">zebra.ui.CommandManager</a></li>
            
                <li><a href="../classes/zebra.ui.CompList.html">zebra.ui.CompList</a></li>
            
                <li><a href="../classes/zebra.ui.ComponentListener.html">zebra.ui.ComponentListener</a></li>
            
                <li><a href="../classes/zebra.ui.Composite.html">zebra.ui.Composite</a></li>
            
                <li><a href="../classes/zebra.ui.CompositeView.html">zebra.ui.CompositeView</a></li>
            
                <li><a href="../classes/zebra.ui.CompRender.html">zebra.ui.CompRender</a></li>
            
                <li><a href="../classes/zebra.ui.CopyCutPaste.html">zebra.ui.CopyCutPaste</a></li>
            
                <li><a href="../classes/zebra.ui.Cursorable.html">zebra.ui.Cursorable</a></li>
            
                <li><a href="../classes/zebra.ui.CursorManager.html">zebra.ui.CursorManager</a></li>
            
                <li><a href="../classes/zebra.ui.designer.ShaperPan.html">zebra.ui.designer.ShaperPan</a></li>
            
                <li><a href="../classes/zebra.ui.Dotted.html">zebra.ui.Dotted</a></li>
            
                <li><a href="../classes/zebra.ui.Etched.html">zebra.ui.Etched</a></li>
            
                <li><a href="../classes/zebra.ui.EventManager.html">zebra.ui.EventManager</a></li>
            
                <li><a href="../classes/zebra.ui.findCanvas().html">zebra.ui.findCanvas()</a></li>
            
                <li><a href="../classes/zebra.ui.FocusListener.html">zebra.ui.FocusListener</a></li>
            
                <li><a href="../classes/zebra.ui.FocusManager.html">zebra.ui.FocusManager</a></li>
            
                <li><a href="../classes/zebra.ui.Font.html">zebra.ui.Font</a></li>
            
                <li><a href="../classes/zebra.ui.Gradient.html">zebra.ui.Gradient</a></li>
            
                <li><a href="../classes/zebra.ui.grid.DefEditors.html">zebra.ui.grid.DefEditors</a></li>
            
                <li><a href="../classes/zebra.ui.grid.Grid.html">zebra.ui.grid.Grid</a></li>
            
                <li><a href="../classes/zebra.ui.grid.GridCaption.html">zebra.ui.grid.GridCaption</a></li>
            
                <li><a href="../classes/zebra.ui.grid.GridStretchPan.html">zebra.ui.grid.GridStretchPan</a></li>
            
                <li><a href="../classes/zebra.ui.grid.Metrics.html">zebra.ui.grid.Metrics</a></li>
            
                <li><a href="../classes/zebra.ui.Group.html">zebra.ui.Group</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlElement.html">zebra.ui.HtmlElement</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlTextArea.html">zebra.ui.HtmlTextArea</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlTextField.html">zebra.ui.HtmlTextField</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlTextInput.html">zebra.ui.HtmlTextInput</a></li>
            
                <li><a href="../classes/zebra.ui.ImageLabel.html">zebra.ui.ImageLabel</a></li>
            
                <li><a href="../classes/zebra.ui.ImagePan.html">zebra.ui.ImagePan</a></li>
            
                <li><a href="../classes/zebra.ui.InputEvent.html">zebra.ui.InputEvent</a></li>
            
                <li><a href="../classes/zebra.ui.KeyEvent.html">zebra.ui.KeyEvent</a></li>
            
                <li><a href="../classes/zebra.ui.KeyListener.html">zebra.ui.KeyListener</a></li>
            
                <li><a href="../classes/zebra.ui.Label.html">zebra.ui.Label</a></li>
            
                <li><a href="../classes/zebra.ui.List.html">zebra.ui.List</a></li>
            
                <li><a href="../classes/zebra.ui.List.ViewProvider.html">zebra.ui.List.ViewProvider</a></li>
            
                <li><a href="../classes/zebra.ui.loadImage().html">zebra.ui.loadImage()</a></li>
            
                <li><a href="../classes/zebra.ui.Manager.html">zebra.ui.Manager</a></li>
            
                <li><a href="../classes/zebra.ui.Menu.html">zebra.ui.Menu</a></li>
            
                <li><a href="../classes/zebra.ui.Menunbar.html">zebra.ui.Menunbar</a></li>
            
                <li><a href="../classes/zebra.ui.MLabel.html">zebra.ui.MLabel</a></li>
            
                <li><a href="../classes/zebra.ui.MouseEvent.html">zebra.ui.MouseEvent</a></li>
            
                <li><a href="../classes/zebra.ui.MouseListener.html">zebra.ui.MouseListener</a></li>
            
                <li><a href="../classes/zebra.ui.MouseWheelSupport.html">zebra.ui.MouseWheelSupport</a></li>
            
                <li><a href="../classes/zebra.ui.PaintManager.html">zebra.ui.PaintManager</a></li>
            
                <li><a href="../classes/zebra.ui.PaintManImpl.html">zebra.ui.PaintManImpl</a></li>
            
                <li><a href="../classes/zebra.ui.Panel.html">zebra.ui.Panel</a></li>
            
                <li><a href="../classes/zebra.ui.PasswordText.html">zebra.ui.PasswordText</a></li>
            
                <li><a href="../classes/zebra.ui.Pattern.html">zebra.ui.Pattern</a></li>
            
                <li><a href="../classes/zebra.ui.Picture.html">zebra.ui.Picture</a></li>
            
                <li><a href="../classes/zebra.ui.PopupInfo.html">zebra.ui.PopupInfo</a></li>
            
                <li><a href="../classes/zebra.ui.PopupLayer.html">zebra.ui.PopupLayer</a></li>
            
                <li><a href="../classes/zebra.ui.PopupManager.html">zebra.ui.PopupManager</a></li>
            
                <li><a href="../classes/zebra.ui.Progress.html">zebra.ui.Progress</a></li>
            
                <li><a href="../classes/zebra.ui.Radial.html">zebra.ui.Radial</a></li>
            
                <li><a href="../classes/zebra.ui.Radiobox.html">zebra.ui.Radiobox</a></li>
            
                <li><a href="../classes/zebra.ui.RadioView.html">zebra.ui.RadioView</a></li>
            
                <li><a href="../classes/zebra.ui.Raised.html">zebra.ui.Raised</a></li>
            
                <li><a href="../classes/zebra.ui.Render.html">zebra.ui.Render</a></li>
            
                <li><a href="../classes/zebra.ui.RootLayer.html">zebra.ui.RootLayer</a></li>
            
                <li><a href="../classes/zebra.ui.RoundBorder.html">zebra.ui.RoundBorder</a></li>
            
                <li><a href="../classes/zebra.ui.Scroll.html">zebra.ui.Scroll</a></li>
            
                <li><a href="../classes/zebra.ui.ScrollManager.html">zebra.ui.ScrollManager</a></li>
            
                <li><a href="../classes/zebra.ui.ScrollPan.html">zebra.ui.ScrollPan</a></li>
            
                <li><a href="../classes/zebra.ui.Slider.html">zebra.ui.Slider</a></li>
            
                <li><a href="../classes/zebra.ui.SplitPan.html">zebra.ui.SplitPan</a></li>
            
                <li><a href="../classes/zebra.ui.StatePan.html">zebra.ui.StatePan</a></li>
            
                <li><a href="../classes/zebra.ui.Sunken.html">zebra.ui.Sunken</a></li>
            
                <li><a href="../classes/zebra.ui.SwitchManager.html">zebra.ui.SwitchManager</a></li>
            
                <li><a href="../classes/zebra.ui.Tabs.html">zebra.ui.Tabs</a></li>
            
                <li><a href="../classes/zebra.ui.TextArea.html">zebra.ui.TextArea</a></li>
            
                <li><a href="../classes/zebra.ui.TextField.html">zebra.ui.TextField</a></li>
            
                <li><a href="../classes/zebra.ui.TextRender.html">zebra.ui.TextRender</a></li>
            
                <li><a href="../classes/zebra.ui.Toolbar.html">zebra.ui.Toolbar</a></li>
            
                <li><a href="../classes/zebra.ui.TooltipInfo.html">zebra.ui.TooltipInfo</a></li>
            
                <li><a href="../classes/zebra.ui.TooltipManager.html">zebra.ui.TooltipManager</a></li>
            
                <li><a href="../classes/zebra.ui.tree.DefEditors.html">zebra.ui.tree.DefEditors</a></li>
            
                <li><a href="../classes/zebra.ui.tree.DefViews.html">zebra.ui.tree.DefViews</a></li>
            
                <li><a href="../classes/zebra.ui.tree.Tree.html">zebra.ui.tree.Tree</a></li>
            
                <li><a href="../classes/zebra.ui.View.html">zebra.ui.View</a></li>
            
                <li><a href="../classes/zebra.ui.ViewPan.html">zebra.ui.ViewPan</a></li>
            
                <li><a href="../classes/zebra.ui.ViewSet.html">zebra.ui.ViewSet</a></li>
            
                <li><a href="../classes/zebra.ui.Window.html">zebra.ui.Window</a></li>
            
                <li><a href="../classes/zebra.ui.WinLayer.html">zebra.ui.WinLayer</a></li>
            
                <li><a href="../classes/zebra.ui.WinListener.html">zebra.ui.WinListener</a></li>
            
                <li><a href="../classes/zebra.ui.zCanvas.html">zebra.ui.zCanvas</a></li>
            
                <li><a href="../classes/zebra.URL.html">zebra.URL</a></li>
            
                <li><a href="../classes/zebra.util.Bag.html">zebra.util.Bag</a></li>
            
                <li><a href="../classes/zebra.util.findInTree().html">zebra.util.findInTree()</a></li>
            
                <li><a href="../classes/zebra.util.Listeners.html">zebra.util.Listeners</a></li>
            
                <li><a href="../classes/zebra.util.newInstance().html">zebra.util.newInstance()</a></li>
            
                <li><a href="../classes/zebra.util.Position.html">zebra.util.Position</a></li>
            
                <li><a href="../classes/zebra.util.Position.Metric.html">zebra.util.Position.Metric</a></li>
            
                <li><a href="../classes/zebra.util.rgb.html">zebra.util.rgb</a></li>
            
        </ul>
    </div>
</div>












        </div>

        <div id="main" class="yui3-u">
            <div class="content"><h4>util.js</h4>

<pre class="code prettyprint linenums">
(function(pkg, Class, Interface) {

/**
 * Number of different utilities methods and classes
 * @module util
 * @main
 * @namespace zebra.util
 * @requires zebra
 */

/**
 * Instantiate a new class instance by the given class name with the specified constructor 
 * arguments.
 * @param  {String} clazz a class name
 * @param  {Array} [args] an arguments list
 * @return {Object}  a new instance of the given class initialized with the specified arguments
 * @for  newInstance()
 * @method newInstance
 */
pkg.newInstance = function(clazz, args) {
    if (args &amp;&amp; args.length &gt; 0) {
        var f = function() {};
        f.prototype = clazz.prototype;
        var o = new f();
        o.constructor = clazz;
        clazz.apply(o, args);
        return o;
    }
    return new clazz();
};
/**
 * @for newInstance()
 */

function hex(v) { return (v &lt; 16) ? [&quot;0&quot;, v.toString(16)].join(&#x27;&#x27;) :  v.toString(16); }

/**
 * Find by xpath-like path an element in a tree-like structure. The method is flexible way to look up 
 * elements in tree structures. The only requirements the passed tree-like structure has to follow is
 * declaring a &quot;kids&quot; array field if the element has a children element. To understand if the given tree 
 * element matches the current path fragment a special equality function has to be passed.
 
        var treeLikeRoot = { 
            value : &quot;Root&quot;, 
            kids : [
                { value: &quot;Item 1&quot; },
                { value: &quot;Item 2&quot; }
            ]
        };

        zebra.util.findInTree(treeLikeRoot, 
                              &quot;/Root/item1&quot;, 
                              function(item, fragment) {
                                  return item.value == fragment;
                              },
                              function(foundElement) {
                                 ...
                                 // true means stop lookaup
                                 return true;   
                              });


 * @param  {Object} root a tree root element. If the element has a children element it has to 
 * declare &quot;kids&quot; field. This field is an array of all children elements
 * @param  {String}   path a xpath-like path. The path has to satisfy number of requirements 
 * and rules:
 
    - &quot;/&quot;&quot; means lookup among all direct children elements 
    - &quot;//&quot;&quot; means lookup among all children elements recursively
    - &quot;*&quot; means any path value 
    -[@attr=100] means number attribute
    -[@attr=true] means boolean attribute
    -[@attr=&#x27;value&#x27;] means string attribute
    - Path has always starts from &quot;/&quot; or &quot;//&quot;
    - Path element always has to be defined: &quot;*&quot; or an symbolic name

 *
 * Path examples:
 
    - &quot;//*&quot; traverse all tree elements
    - &quot;//*[@a=10]&quot; traverse all tree elements that has an attribute &quot;a&quot; that equals 10
    - &quot;/Root/Item&quot; find an element by exact path 

 * @param  {Function}  eq  an equality function. The function gets current evaluated tree element  
 * and a path fragment against which the tree element has to be evaluated. It is expected the method 
 * returns boolean value to say if the given passed tree element matches the path fragment.  
 * @param  {Function} cb callback function that is called every time a new tree element
 * matches the given path fragment. The function has to return true if the tree look up
 * has to be stopped
 * @for  findInTree()
 * @method findInTree
 */
pkg.findInTree = function(root, path, eq, cb) {
    var findRE = /(\/\/|\/)?([^\[\/]+)(\[\s*(\@[a-zA-Z_][a-zA-Z0-9_\.]*)\s*\=\s*([0-9]+|true|false|\&#x27;[^&#x27;]*\&#x27;)\s*\])?/g,
        m = null, res = [];

    function _find(root, ms, idx, cb) {
        function list_child(r, name, deep, cb) {
            if (r.kids) {
                for (var i=0; i &lt; r.kids.length; i++) {
                    var kid = r.kids[i];
                    if (name == &#x27;*&#x27; || eq(kid, name)) {
                        if (cb(kid)) return true;
                    }

                    if (deep &amp;&amp; list_child(kid, name, deep, cb)) {
                        return true;
                    }
                }
            }
            return false;
        }

        if (ms == null || idx &gt;= ms.length) return cb(root);

        var m = ms[idx];
        return list_child(root, m[2], m[1] == &quot;//&quot;, function(child) {
            if (m[3] &amp;&amp; child[m[4].substring(1)] != m[5]) return false;
            return _find(child, ms, idx + 1, cb);
        });
    }

    var c = 0;
    while (m = findRE.exec(path)) {
        if (m[1] == null || m[2] == null || m[2].trim().length === 0) {
            break;
        }

        c += m[0].length;


        if (m[3] &amp;&amp; m[5][0] == &quot;&#x27;&quot;) m[5] = m[5].substring(1, m[5].length - 1);
        res.push(m);
    }

    if (res.length == 0 || c &lt; path.length) {
        throw new Error(&quot;Invalid path: &#x27;&quot; + path + &quot;&#x27;,&quot; + c);
    }

    _find({ kids:[root] }, res, 0, cb);
};
/**
 * @for findInTree()
 */


/**
 * Rgb color class. This class represents rgb(a) color as JavaScript structure:
 
       // rgb color
       var rgb1 = new zebra.util.rgb(100,200,100);

       // rgb with transparency 
       var rgb2 = new zebra.util.rgb(100,200,100, 0.6);
       
       // encoded as a string rgb color
       var rgb3 = new zebra.util.rgb(&quot;rgb(100,100,200)&quot;);

       // hex rgb color
       var rgb3 = new zebra.util.rgb(&quot;#CCDDFF&quot;);

 * @param  {Integer|String} r  red color intensity or if this is the only constructor parameter it denotes 
 * encoded in string rgb color
 * @param  {Integer} [g]  green color intensity
 * @param  {Integer} [b] blue color intensity
 * @param  {Float}   [a] alpha color intensity
 * @constructor
 * @class rgb
 */
pkg.rgb = function (r, g, b, a) {

    /**
     * Red color intensity
     * @attribute r 
     * @type {Integer}
     * @readOnly
     */

    /**
     * Green color intensity
     * @attribute g
     * @type {Integer}
     * @readOnly
     */

    /**
     * Blue color intensity
     * @attribute b
     * @type {Integer}
     * @readOnly
     */

    /**
     * Alpha
     * @attribute a
     * @type {Float}
     * @readOnly
     */
    
    if (arguments.length == 1) {
        if (zebra.isString(r)) {
            this.s = r;
            if (r[0] === &#x27;#&#x27;) {
                r = parseInt(r.substring(1), 16);
            }
            else {
                if (r[0] === &#x27;r&#x27; &amp;&amp; r[1] === &#x27;g&#x27; &amp;&amp; r[2] === &#x27;b&#x27;) {
                    var i = r.indexOf(&#x27;(&#x27;, 3), p = r.substring(i + 1, r.indexOf(&#x27;)&#x27;, i + 1)).split(&quot;,&quot;);
                    this.r = parseInt(p[0].trim(), 10);
                    this.g = parseInt(p[1].trim(), 10);
                    this.b = parseInt(p[2].trim(), 10);
                    if (p.length &gt; 3) this.a = parseInt(p[3].trim(), 10);
                    return;
                }
            }
        }
        this.r =  r &gt;&gt; 16;
        this.g = (r &gt;&gt; 8) &amp; 0xFF;
        this.b = (r &amp; 0xFF);
    }
    else {
        this.r = r;
        this.g = g;
        this.b = b;
        if (arguments.length &gt; 3) this.a = a;
    }

    if (this.s == null) {
        this.s = (typeof this.a !== &quot;undefined&quot;) ? [&#x27;rgba(&#x27;, this.r, &quot;,&quot;, this.g, &quot;,&quot;,
                                                             this.b, &quot;,&quot;, this.a, &quot;)&quot;].join(&#x27;&#x27;)
                                                 : [&#x27;#&#x27;, hex(this.r), hex(this.g), hex(this.b)].join(&#x27;&#x27;);
    }
};

var rgb = pkg.rgb;
rgb.prototype.toString = function() { return this.s; };

// rgb.prototype.equals = function(c){
//     return c != null &amp;&amp; (c === this || (this.r == c.r &amp;&amp; this.b == c.b &amp;&amp; this.g == c.g &amp;&amp; this.a == c.a));
// };

rgb.black     = new rgb(0);
rgb.white     = new rgb(0xFFFFFF);
rgb.red       = new rgb(255,0,0);
rgb.blue      = new rgb(0,0,255);
rgb.green     = new rgb(0,255,0);
rgb.gray      = new rgb(128,128,128);
rgb.lightGray = new rgb(211,211,211);
rgb.darkGray  = new rgb(169,169,169);
rgb.orange    = new rgb(255,165,0);
rgb.yellow    = new rgb(255,255,0);
rgb.pink      = new rgb(255,192,203);
rgb.cyan      = new rgb(0,255,255);
rgb.magenta   = new rgb(255,0,255);
rgb.darkBlue  = new rgb(0, 0, 140);

pkg.Actionable = Interface();

pkg.index2point  = function(offset,cols) { return [~~(offset / cols), (offset % cols)]; };
pkg.indexByPoint = function(row,col,cols){ return (cols &lt;= 0) ?  -1 : (row * cols) + col; };

pkg.intersection = function(x1,y1,w1,h1,x2,y2,w2,h2,r){
    r.x = x1 &gt; x2 ? x1 : x2;
    r.width = Math.min(x1 + w1, x2 + w2) - r.x;
    r.y = y1 &gt; y2 ? y1 : y2;
    r.height = Math.min(y1 + h1, y2 + h2) - r.y;
};

pkg.isIntersect = function(x1,y1,w1,h1,x2,y2,w2,h2){
    return (Math.min(x1 + w1, x2 + w2) - (x1 &gt; x2 ? x1 : x2)) &gt; 0 &amp;&amp;
           (Math.min(y1 + h1, y2 + h2) - (y1 &gt; y2 ? y1 : y2)) &gt; 0;
};

pkg.unite = function(x1,y1,w1,h1,x2,y2,w2,h2,r){
    r.x = x1 &lt; x2 ? x1 : x2;
    r.y = y1 &lt; y2 ? y1 : y2;
    r.width  = Math.max(x1 + w1, x2 + w2) - r.x;
    r.height = Math.max(y1 + h1, y2 + h2) - r.y;
};

pkg.arraycopy = function(src, spos, dest, dpos, dlen) {
    for(var i=0; i&lt;dlen; i++) dest[i + dpos] = src[spos + i];
};

pkg.currentTimeMillis = function() { return (new Date()).getTime(); };

pkg.str2bytes = function(s) {
    var ar = [];
    for (var i = 0; i &lt; s.length; i++) {
        var code = s.charCodeAt(i);
        ar.push((code &gt;&gt; 8) &amp; 0xFF);
        ar.push(code &amp; 0xFF);
    }
    return ar;
};

var digitRE = /[0-9]/;
pkg.isDigit = function(ch) {
    if (ch.length != 1) throw new Error(&quot;Incorrect character&quot;);
    return digitRE.test(ch);
};

var letterRE = /[A-Za-z]/;
pkg.isLetter = function (ch) {
    if (ch.length != 1) throw new Error(&quot;Incorrect character&quot;);
    return letterRE.test(ch);
};

/**
 * This this META class is handy container to keep different types of listeners and
 * fire events to the listeners:
 
        // create listener container to keep three different events 
        // handlers
        var MyListenerContainerClass = zebra.util.Listeners.Class(&quot;event1&quot;, 
                                                                  &quot;event2&quot;, 
                                                                  &quot;event3&quot;); 

        // instantiate listener class container
        var listeners = new MyListenerContainerClass();

        // add &quot;event1&quot; listener 
        listeners.add(function event1() {
            ...
        });

        // add &quot;event2&quot; listener 
        listeners.add(function event2() {
           ...
        });

        // and firing event1 to registered handlers
        listeners.event1(...); 

        // and firing event2 to registered handlers
        listeners.event2(...); 

 * @class Listeners
 * @constructor
 * @param {String} [events]* events types the container has to support 
 */
var $NewListener = function() {
    if (arguments.length === 0) arguments = [ &quot;fired&quot; ];

    var clazz = function() {};

    if (arguments.length == 1) {
        var name = arguments[0];

        clazz.prototype.add = function(l) {
            if (this.v == null) this.v = [];
            var ctx = this;
            if (typeof l !== &#x27;function&#x27;) {
                ctx = l;
                l   = l[name]; 
                if (l == null || typeof l !== &quot;function&quot;) {
                    throw new Error(&quot;Instance doesn&#x27;t declare &#x27;&quot; + names + &quot;&#x27; listener method&quot;);
                }
            }
            this.v.push(ctx, l);
            return l;
        };

        clazz.prototype.remove = function(l) {
            if (this.v != null) {
                var i = 0;
                while((i = this.v.indexOf(l)) &gt;= 0) {
                    if (i%2 &gt; 0) i--;
                    this.v.splice(i, 2);
                }
            }
        };

        clazz.prototype.removeAll = function() { if (this.v != null) this.v.length = 0; };

        clazz.prototype[name] = function() {
            if (this.v != null) {
                for(var i = 0;i &lt; this.v.length; i+=2) {
                    this.v[i + 1].apply(this.v[i], arguments);
                }
            }
        };
    }
    else {
        var names = {};
        for(var i=0; i&lt; arguments.length; i++) {
            names[arguments[i]] = true;
        }

        clazz.prototype.add = function(l) {
            if (this.methods == null) this.methods = {};

            if (typeof l === &#x27;function&#x27;) {
                var n = zebra.$FN(l);
                if (names[n] == null) {
                    throw new Error(&quot;Unknown listener &quot; + n);
                }

                if (!this.methods[n]) this.methods[n] = [];
                this.methods[n].push(this, l);
            }
            else {
                var b = false;
                for(var k in names) {
                    if (typeof l[k] === &quot;function&quot;) {
                        b = true;
                        if (this.methods[k] == null) this.methods[k] = [];
                        this.methods[k].push(l, l[k]);
                    }
                }
                if (b === false) throw new Error(&quot;No listener methods have been found&quot;);
            }
            return l;
        };

        for(var i=0; i&lt;arguments.length; i++) {
            var m = arguments[i];
            (function(m) {
                clazz.prototype[m] = function() {
                    if (this.methods != null) {
                        var c = this.methods[m];
                        if (c != null) {
                            for(var i=0; i &lt; c.length; i+=2) c[i+1].apply(c[i], arguments);
                        }
                    }
                };
            })(m);
        }

        clazz.prototype.remove = function(l) {
            if (this.methods != null) {
                for(var k in this.methods) {
                    var v = this.methods[k], i = 0;
                    while((i = v.indexOf(l)) &gt;= 0) {
                        if (i%2 &gt; 0) i--;
                        v.splice(i, 2);
                    }
                    if (v.length === 0) delete this.methods[k];
                }
            }
        };

        clazz.prototype.removeAll = function() {
            if (this.methods != null) {
                for(var k in this.methods) {
                    if (this.methods.hasOwnProperty(k)) this.methods[k].length = 0;
                }
                this.methods = {};
            }
        };
    }
    return clazz;
};

pkg.Listeners = $NewListener();
pkg.Listeners.Class = $NewListener;

/**
 * Useful class to track a virtual cursor position in a structure that has 
 * dedicated number of lines where every line has a number of elements. The 
 * structure metric has to be described by providing an instance of  
 * zebra.util.Position.Metric interface that discovers how many 
 * lines the structure has and how many elements every line includes.
 * @param {zebra.util.Position.Metric} m a position metric
 * @constructor
 * @class  Position
 */

/**
 * Fire when a virtual cursor position has been updated
 
        position._.add(function(src, prevOffset, prevLine, prevCol) {
            ...
        });

 * @event posChanged
 * @param {zebra.util.Position} src an object that triggers the event
 * @param {Integer} prevOffest a previous virtual cursor offset
 * @param {Integer} prevLine a previous virtual cursor line
 * @param {Integer} prevCol a previous virtual cursor column in the previous line
 */
var PosListeners = pkg.Listeners.Class(&quot;posChanged&quot;), Position = pkg.Position = Class([
    function $clazz() {
        /**
         * Position metric interface. This interface is designed for describing 
         * a navigational structure that consists on number of lines where
         * every line consists of number of elements
         * @class Position.Metric
         * @for zebra.util.Position
         */
        
        /**
         * Get number of lines to navigate through  
         * @return {Integer} a number of lines
         * @for zebra.util.Position.Metric
         * @method  getLines
         */

         /**
          * Get a number of elements in the given line
          * @param {Integer} l a line index
          * @return {Integer} a number of elements in a line
          * @for zebra.util.Position.Metric
          * @method  getLineSize
          */



         /**
          * Get a maximal element index (a last element of a last line)
          * @return {Integer} a maximal element index
          * @for zebra.util.Position.Metric
          * @method  getMaxOffset
          */

         /**
          * @for zebra.util.Position
          */
         
        this.Metric = Interface();
        
        this.DOWN = 1;
        this.UP   = 2;
        this.BEG  = 3;
        this.END  = 4;
    },

    function $prototype() {
        /**
         * Clear virtual cursor position to undefined (-1) 
         * @method clearPos
         */
        this.clearPos = function (){
            if (this.offset &gt;= 0){
                var prevOffset = this.offset, prevLine = this.currentLine, prevCol = this.currentCol;
                this.offset  = this.currentLine = this.currentCol = -1;
                this._.posChanged(this, prevOffset, prevLine, prevCol);
            }
        };

        /**
         * Set the specified virtual cursor offsest
         * @param {Integer} o an offset
         * @method setOffset
         */
        this.setOffset = function(o){
            if(o &lt; 0) o = 0;
            else {
                var max = this.metrics.getMaxOffset();
                if(o &gt;= max) o = max;
            }

            if(o != this.offset){
                var prevOffset = this.offset, prevLine = this.currentLine, prevCol = this.currentCol,  p = this.getPointByOffset(o);
                this.offset = o;
                if(p != null){
                    this.currentLine = p[0];
                    this.currentCol = p[1];
                }
                this.isValid = true;
                this._.posChanged(this, prevOffset, prevLine, prevCol);
            }
        };

        /**
         * Seek virtual cursor offset with the given shift
         * @param {Integer} off a shift
         * @method seek
         */
        this.seek = function(off){ this.setOffset(this.offset + off); };

        /**
         * Set the vurtual cursor line and the given column in the line 
         * @param {Integer} r a line
         * @param {Integer} c a column in the line
         * @method setRowCol
         */
        this.setRowCol = function (r,c){
            if(r != this.currentLine || c != this.currentCol){
                var prevOffset = this.offset, prevLine = this.currentLine, prevCol = this.currentCol;
                this.offset = this.getOffsetByPoint(r, c);
                this.currentLine = r;
                this.currentCol = c;
                this._.posChanged(this, prevOffset, prevLine, prevCol);
            }
        };

        this.inserted = function (off,size){
            if(this.offset &gt;= 0 &amp;&amp; off &lt;= this.offset){
                this.isValid = false;
                this.setOffset(this.offset + size);
            }
        };

        this.removed = function (off,size){
            if(this.offset &gt;= 0 &amp;&amp; this.offset &gt;= off){
                this.isValid = false;
                if(this.offset &gt;= (off + size)) this.setOffset(this.offset - size);
                else this.setOffset(off);
            }
        };

        /**
         * Calculate a line and line column by the given offset. 
         * @param  {Integer} off an offset
         * @return {Array} an array that contains a line as the first 
         * element and a column in the line as the second element. 
         * @method getPointByOffset
         */
        this.getPointByOffset = function(off){
            if (off == -1) return [-1, -1];
            var m = this.metrics, max = m.getMaxOffset();
            if (off &gt; max) throw new Error(&quot;Out of bounds:&quot; + off);
            if (max === 0) return [(m.getLines() &gt; 0 ? 0 : -1), 0];
            if (off === 0) return [0, 0];
            var d = 0, sl = 0, so = 0;
            if (this.isValid &amp;&amp; this.offset !=  -1){
                sl = this.currentLine;
                so = this.offset - this.currentCol;
                if(off &gt; this.offset) d = 1;
                else
                    if(off &lt; this.offset) d =  -1;
                    else return [sl, this.currentCol];
            }
            else{
                d = (~~(max / off) === 0) ?  -1 : 1;
                if(d &lt; 0){
                    sl = m.getLines() - 1;
                    so = max - m.getLineSize(sl);
                }
            }
            for(; sl &lt; m.getLines() &amp;&amp; sl &gt;= 0; sl += d){
                var ls = m.getLineSize(sl);
                if(off &gt;= so &amp;&amp; off &lt; so + ls) return [sl, off - so];
                so += d &gt; 0 ? ls : -m.getLineSize(sl - 1);
            }
            return [-1, -1];
        };

        /**
         * Calculate an offset by the given line and column in the line 
         * @param  {Integer} row a line 
         * @param  {Integer} col a column in the line
         * @return {Integer} an offset
         * @method getOffsetByPoint
         */
        this.getOffsetByPoint = function (row,col){
            var startOffset = 0, startLine = 0, m = this.metrics;

            if (row &gt;= m.getLines() || col &gt;= m.getLineSize(row)) throw new Error();
            if (this.isValid &amp;&amp; this.offset !=  -1) {
                startOffset = this.offset - this.currentCol;
                startLine = this.currentLine;
            }
            if (startLine &lt;= row) for(var i = startLine;i &lt; row; i++) startOffset += m.getLineSize(i);
            else for(var i = startLine - 1;i &gt;= row; i--) startOffset -= m.getLineSize(i);
            return startOffset + col;
        };

        /**
         * Calculate maximal possible offset
         * @protected
         * @method calcMaxOffset
         * @return {Integer} a maximal possible offset
         */
        this.calcMaxOffset = function (){
            var max = 0, m = this.metrics;
            for(var i = 0;i &lt; m.getLines(); i ++ ) max += m.getLineSize(i);
            return max - 1;
        };

        /**
         * Seek virtual cursor to the next position. How the method has to seek to the next position
         * has to be denoted by one of the following constants:
    
    - **zebra.util.Position.BEG** seek cursor to the begin of the current line
    - **zebra.util.Position.END** seek cursor to the end of the current line
    - **zebra.util.Position.UP** seek cursor one line up
    - **zebra.util.Position.DOWN** seek cursor one line down 
    
         * If the current virtual position is not known (-1) the method always sets 
         * it to the first line, the first column in the line (offset is zero).
         * @param  {Integer} t   an action the seek has to be done
         * @param  {Integer} num number of seek actions 
         * @method seekLineTo
         */
        this.seekLineTo = function(t,num){
            if(this.offset &lt; 0){
                this.setOffset(0);
                return;
            }

            if (arguments.length == 1) num = 1;

            var prevOffset = this.offset, prevLine = this.currentLine, prevCol = this.currentCol;
            switch(t)
            {
                case Position.BEG:
                    if(this.currentCol &gt; 0){
                        this.offset -= this.currentCol;
                        this.currentCol = 0;
                        this._.posChanged(this, prevOffset, prevLine, prevCol);
                    } break;
                case Position.END:
                    var maxCol = this.metrics.getLineSize(this.currentLine);
                    if (this.currentCol &lt; (maxCol - 1)){
                        this.offset += (maxCol - this.currentCol - 1);
                        this.currentCol = maxCol - 1;
                        this._.posChanged(this, prevOffset, prevLine, prevCol);
                    } break;
                case Position.UP:
                    if (this.currentLine &gt; 0){
                        this.offset -= (this.currentCol + 1);
                        this.currentLine--;
                        for(var i = 0;this.currentLine &gt; 0 &amp;&amp; i &lt; (num - 1); i++ , this.currentLine--){
                            this.offset -= this.metrics.getLineSize(this.currentLine);
                        }
                        var maxCol = this.metrics.getLineSize(this.currentLine);
                        if (this.currentCol &lt; maxCol) this.offset -= (maxCol - this.currentCol - 1);
                        else this.currentCol = maxCol - 1;
                        this._.posChanged(this, prevOffset, prevLine, prevCol);
                    } break;
                case Position.DOWN:
                    if (this.currentLine &lt; (this.metrics.getLines() - 1)){
                        this.offset += (this.metrics.getLineSize(this.currentLine) - this.currentCol);
                        this.currentLine++;
                        var size = this.metrics.getLines() - 1;
                        for(var i = 0;this.currentLine &lt; size &amp;&amp; i &lt; (num - 1); i++ ,this.currentLine++ ){
                            this.offset += this.metrics.getLineSize(this.currentLine);
                        }
                        var maxCol = this.metrics.getLineSize(this.currentLine);
                        if (this.currentCol &lt; maxCol) this.offset += this.currentCol;
                        else {
                            this.currentCol = maxCol - 1;
                            this.offset += this.currentCol;
                        }
                        this._.posChanged(this, prevOffset, prevLine, prevCol);
                    } break;
                default: throw new Error();
            }
        };

        this[&#x27;&#x27;] = function(pi){
            this._ = new PosListeners();
            this.isValid = false;

            /**
             * Current virtual cursor line position
             * @attribute currentLine
             * @type {Integer}
             * @readOnly
             */

            /**
             * Current virtual cursor column position
             * @attribute currentCol
             * @type {Integer}
             * @readOnly
             */
            
            /**
             * Current virtual cursor offset
             * @attribute offset
             * @type {Integer}
             * @readOnly
             */

            this.currentLine = this.currentCol = this.offset = 0;
            this.setMetric(pi);
        };

        /**
         * Set position metric. Metric describes how many lines  
         * and elements in these line the virtual cursor can be navigated
         * @param {zebra.util.Position.Metric} p a position metric
         * @method setMetric
         */
        this.setMetric = function (p){
            if (p == null) throw new Error(&quot;Null metric&quot;);
            if (p != this.metrics){
                this.metrics = p;
                this.clearPos();
            }
        };
    }
]);

pkg.timer = new (function() {
    var quantum = 40;

    this.runners =  Array(5);
    this.count   =  0;
    this.pid     = -1;
    for(var i = 0; i &lt; this.runners.length; i++) this.runners[i] = { run:null };

    this.get = function(r) {
        if (this.count &gt; 0) {
            for(var i=0; i &lt; this.runners.length; i++) {
                var c = this.runners[i];
                if (c.run != null &amp;&amp; c.run == r) return c;
            }
        }
        return null;
    };

    this.start = function(r, startIn, repeatIn){
        if (arguments.length &lt; 3) repeatIn = 150;
        if (arguments.length &lt; 2) startIn  = 150;

        var ps = this.runners.length;
        if (this.count == ps) throw new Error(&quot;Out of runners limit&quot;);

        var ci = this.get(r);
        if (ci == null) {
            var runners = this.runners, $this = this;
            for(var i=0; i &lt; ps; i++) {
                var j = (i + this.count) % ps, c = runners[j];
                if (c.run == null) {
                    c.run = r;                      
                    c.si  = startIn;
                    c.ri  = repeatIn;
                    break;
                }
            }
            this.count++;

            if (this.count == 1) {
                this.pid = window.setInterval(function() {
                    for(var i = 0; i &lt; ps; i++) {
                        var c = runners[i];
                        if (c.run != null) {
                            if (c.si &lt;= 0) {
                                try      { c.run.run(); }
                                catch(e) { zebra.print(e); }
                                c.si += c.ri;
                            }
                            else c.si -= quantum;
                        }
                    }
                    if ($this.count === 0) { 
                        window.clearInterval($this.pid);
                        $this.pid = -1;
                    }
                }, quantum);
            }
        }
        else {
            ci.si = startIn;
            ci.ri = repeatIn;
        }

        return r;
    };

    this.stop = function(l) {
        this.get(l).run = null;
        this.count--;
        if (this.count == 0 &amp;&amp; this.pid &gt;= 0) {
            window.clearInterval(this.pid);
            this.pid = -1;
        }
    };

    this.clear = function(l){
        var c = this.get(l);
        c.si = c.ri;
    };
})();

/**
 * JSON configuration objects loader class. The class is handy way to keep and load configuration 
 * encoded in JSON format. Except standard JSON types the class uses number of JSON values and key 
 * interpretations such as:
  
    - **&quot;@key_of_refernced_value&quot;** String values that start from &quot;@&quot; character are considered 
      as a reference to other values 
    - **{ &quot;$class_name&quot;:[ arg1, arg2, ...], &quot;prop1&quot;: ...}** Key names that starts from &quot;$&quot; character 
      are considered as name of class that has to be instantiated as the value
    - **{&quot;?isToucable&quot;: { &quot;label&quot;: true } }** Key names that start from &quot;?&quot; are considered as
      conditional section.   

 * Also the class support section inheritance. That means you can say to include part of JSON 
 * to another part of JSON. For instance, imagine JSON describes properties for number of UI 
 * components where an UI component can inherits another one. 
 
        {
           // base component  
           &quot;BaseComponent&quot;: {
               &quot;background&quot;: &quot;red&quot;,
               &quot;border&quot;: &quot;plain&quot;,
               &quot;size&quot;: [300, 300]
           },

            // component that inherits properties from BaseComponent,
            // but override background property with own value
           &quot;ExtenderComp&quot;: {
               &quot;$inherit&quot;: &quot;BaseComponent&quot;,
               &quot;background&quot;: &quot;green&quot;
           }
        }
 
 * 
 * The loading of JSON can be multi steps procedure where you can load few JSON. That means
 * you can compose the final configuration from number of JSON files:
 
        // prepare object that will keep loaded data
        var loadedData = {}; 

        // create bag
        var bag = zebra.util.Bag(loadedData);

        // load the bag with two JSON
        bag.load(&quot;{ ... }&quot;, false).load(&quot;{  ...  }&quot;);


 * @class Bag
 * @constructor
 * @param {Object} [obj] a root object to be loaded with the given JSON configuration  
 */
pkg.Bag = zebra.Class([
    function $prototype() {
        /**
         * The attribute rules how arrays have to be merged if the bag is loaded from few 
         * JSON sources. true means that if a two JSON have the same key that reference to
         * array values the final value will be a concatenation of the two arrays from the 
         * two JSON sources.
         * @attribute concatArrays
         * @type {Boolean}
         * @default false
         */
        this.concatArrays = false;

        /**
         * The property says if the object introspection is required to try find a setter 
         * method for the given key. For instance if an object is loaded with the 
         * following JSON:
         
         {
            &quot;color&quot;: &quot;red&quot;
         }
        
         * the introspection will cause bag class to try finding &quot;setColor(c)&quot; method in 
         * the loaded with the JSON object and call it to set &quot;red&quot; property value.  
         * @attribute usePropertySetters
         * @default true
         * @type {Boolean}
         */
        this.usePropertySetters = true;

        this.ignoreNonExistentKeys = false;

        this.get = function(key) {
            if (key == null) throw new Error(&quot;Null key&quot;);
            var n = key.split(&#x27;.&#x27;), v = this.objects;
            for(var i = 0; i &lt; n.length; i++) {
                v = v[n[i]];
                if (typeof v === &quot;undefined&quot;) {
                    if (this.ignoreNonExistentKeys) return v;
                    throw new Error(&quot;Property &#x27;&quot; + key + &quot;&#x27; not found&quot;);
                }
            }
            return v != null &amp;&amp; v.$new ? v.$new() : v;
        };

        this.mergeContent = function(o, v) {
            if (v === null || zebra.isNumber(v) || zebra.isBoolean(v) || zebra.isString(v)) {
                return v;
            }

            if (Array.isArray(v)) {
                if (this.concatArrays === false) {
                    return v;
                }

                if (o &amp;&amp; Array.isArray(o) === false) {
                    throw new Error(&quot;Array merging type inconsistency: &quot; + o);
                }
                return o ? o.concat(v) : v;
            }

            for (var k in v) {
                if (v.hasOwnProperty(k)) {
                    if (k[0] == &#x27;?&#x27;) {
                        if (eval(k.substring(1).trim())) {
                            o = this.mergeContent(o, v[k]);
                        }
                        continue;
                    }
                    o[k] = o.hasOwnProperty(k) ? this.mergeContent(o[k], v[k]) : v[k];
                }
            }
            return o;
        };

        // create, merge to o and return a value by the given description d that is designed to be assigned to o
        // -- atomic types int string boolean number are returned as is
        // -- created by the given description array are append to o array
        // -- structure description (dictionary) are merged to o
        this.mergeObjWithDesc = function(o, d) {
            // atomic type should be returned as is
            if (d === null || zebra.isNumber(d) || zebra.isBoolean(d)) {
                return d;
            }

            // array should be merged (concatenated)
            if (Array.isArray(d)) {
                var v = [];
                for(var i=0; i&lt; d.length; i++) v[i] = this.mergeObjWithDesc(null, d[i]);
                if (this.concatArrays === false) {
                    return v;
                }

                if (o &amp;&amp; Array.isArray(o) === false) {
                    throw new Error(&quot;Destination has to be array: &quot; + o);
                }
                return (o != null) ? o.concat(v) : v;
            }

            // string is atomic, but  string can encode type other than string, decode string
            // (if necessary) by calling decodeStringValue method
            if (zebra.isString(d)) {
                return (d[0] == &quot;@&quot;) ? this.get(d.substring(1))
                                     : (this.decodeStringValue ? this.decodeStringValue(d) : d);
            }

            // store and cleanup $inherit synthetic field from description.
            var inh = null;
            if (d.hasOwnProperty(&quot;$inherit&quot;)) {
                inh = d[&quot;$inherit&quot;];
                delete d[&quot;$inherit&quot;];
            }

            // test whether we have a class definition
            for (var k in d) {
                // handle class definition
                if (k[0] == &#x27;$&#x27; &amp;&amp; d.hasOwnProperty(k)) {
                    var classname = k.substring(1).trim(), args = d[k];
                    args = this.mergeObjWithDesc(null, Array.isArray(args) ? args : [ args ]);
                    delete d[k];

                    if (classname[0] == &quot;*&quot;) {
                        return (function(clazz, args) {
                            return {
                                $new : function() { return pkg.newInstance(clazz, args); }
                            };
                        })(this.resolveClass(classname.substring(1).trim()), args);
                    }
                    return this.mergeObjWithDesc(pkg.newInstance(this.resolveClass(classname), args), d);
                }

                //!!!! trust the name of class occurs first what in general cannot be guaranteed by JSON spec
                //     but we can trust since many other third party applications stands on it too :)
                break;
            }

            // the description is not atomic or array type. it can be either a number of fields that should be
            // merged with appropriate field of &quot;o&quot; object, or it can define how to instantiate an instance of a
            // class. There is one special case: &quot;.name&quot; property says that object is created by calling
            // &quot;name&quot; method
            var v = (o == null || zebra.isNumber(o) || zebra.isBoolean(o) || zebra.isString(o) || Array.isArray(o)) ? d : o;

            for (var k in d) {
                if (d.hasOwnProperty(k)) {
                    // special field name that says to call method to create a value by the given description
                    if (k[0] == &quot;.&quot;) {
                        var vv = d[k];
                        if (Array.isArray(vv) === false) vv = [ vv ];
                        return this.objects[k.substring(1).trim()].apply(this.objects, this.mergeObjWithDesc(null, vv));
                    }

                    var po = o &amp;&amp; o.hasOwnProperty(k) ? o[k] : null;

                   // v[k] = d[k];

                    var nv = this.mergeObjWithDesc(po, d[k]);
                    if (this.usePropertySetters &amp;&amp; k[0] != &#x27;.&#x27;) {
                        m  = zebra.getPropertySetter(v, k);
                        if (m != null) {
                            if (m.length &gt; 1) m.apply(v, nv);
                            else              m.call(v, nv);
                            continue;
                        }
                    }
                    v[k] = nv;
                }
            }

            if (inh !== null) this.inherit(v, inh);
            return v;
        };

        /**
         * Called every time the given class name has to be transformed into 
         * the class object (constructor) reference. 
         * @param  {String} clazz a class name
         * @return {Function}   a class reference
         * @method resolveClass
         */
        this.resolveClass = function (clazz) {
            return this.aliases.hasOwnProperty(clazz) ? this.aliases[clazz]
                                                      : zebra.Class.forName(clazz);
        };

        this.inherit = function(o, pp) {
            for(var i=0; i &lt; pp.length; i++) {
                var op = this.objects, n = pp[i].trim(), nn = n.split(&quot;.&quot;), j = 0;
                while (j &lt; nn.length) {
                    op = op[nn[j++]];
                    if (op == null) {
                        throw new Error(&quot;Wrong inherit path &#x27;&quot; + n + &quot;(&quot; + nn[j-1] + &quot;)&#x27;&quot;);
                    }
                }

                for(var k in op) {
                    if (op.hasOwnProperty(k) &amp;&amp; o.hasOwnProperty(k) === false) o[k] = op[k];
                }
            }
        };

        /**
         * Load the given JSON content and parse if the given flag is true. The passed  
         * boolean flag controls parsing. The flag is used to load few JSON. Before 
         * parsing the JSONs are merged and than the final result is parsed.
         * @param  {String} s a JSON content to be loaded
         * @param  {Boolean} [b] true if the loading has to be completed
         * @return {zebra.ui.Bag} the bag itself
         * @method load
         */
        this.load = function (s, b) {
            if (this.isloaded === true) { 
                throw new Error(&quot;Load is done&quot;);
            }

            if (arguments.length == 1) {
                b = true;
            }

            var content = null;
            try { content = JSON.parse(s); }
            catch(e) {
                throw new Error(&quot;JSON  loading error: &quot; + e);
            }
            this.content = this.mergeContent(this.content, content);
            if (this.loaded) this.loaded(this.content);
            if (b === true) this.end();
            return this;
        };

        /**
         * End loading JSONs and parse final result
         * @method end
         */
        this.end = function() {
            if (typeof this.isloaded === &quot;undefined&quot;) {
                this.isloaded = true;
                if (this.content.hasOwnProperty(&quot;$aliases&quot;)) {
                    var aliases = this.content[&quot;$aliases&quot;];
                    for(var k in aliases) {
                        this.aliases[k.trim()] = Class.forName(aliases[k].trim());
                    }
                    delete this.content[&quot;$aliases&quot;];
                }
                this.objects = this.mergeObjWithDesc(this.objects, this.content);
            }
        };

        this[&#x27;&#x27;] = function (container) {
            this.aliases = {};
            this.objects = arguments.length === 0 ? {} : container;
            this.content = {};
        };
    }
]);

})(zebra(&quot;util&quot;), zebra.Class, zebra.Interface);
</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/js/tabs.js"></script>
</body>
</html>
